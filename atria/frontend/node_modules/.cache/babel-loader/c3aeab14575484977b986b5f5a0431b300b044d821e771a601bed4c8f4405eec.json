{"ast":null,"code":"class t {\n  constructor(t, e) {\n    this.operator = t, this.value = e, Object.defineProperty(this, \"t\", {\n      writable: !0\n    });\n  }\n  get notes() {\n    return this.t;\n  }\n  addNote(t) {\n    this.t = this.t || [], this.t.push(t);\n  }\n}\nclass e extends t {}\nclass r extends e {\n  constructor(t, e) {\n    if (!Array.isArray(e)) throw new Error(`\"${t}\" operator expects to receive an array of conditions`);\n    super(t, e);\n  }\n}\nconst n = \"__itself__\";\nclass o extends t {\n  constructor(t, e, r) {\n    super(t, r), this.field = e;\n  }\n}\nconst s = new e(\"__null__\", null),\n  i = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\nfunction c(t, e) {\n  return e instanceof r && e.operator === t;\n}\nfunction u(t, e) {\n  return 1 === e.length ? e[0] : new r(t, function t(e, r, n) {\n    const o = n || [];\n    for (let n = 0, s = r.length; n < s; n++) {\n      const s = r[n];\n      c(e, s) ? t(e, s.value, o) : o.push(s);\n    }\n    return o;\n  }(t, e));\n}\nconst a = t => t,\n  h = () => Object.create(null),\n  f = Object.defineProperty(h(), \"__@type@__\", {\n    value: \"ignore value\"\n  });\nfunction l(t, e) {\n  let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n  if (!t || t && t.constructor !== Object) return !1;\n  for (const n in t) {\n    if (i(t, n) && i(e, n) && (!r || t[n] !== f)) return !0;\n  }\n  return !1;\n}\nfunction d(t) {\n  const e = [];\n  for (const r in t) i(t, r) && t[r] !== f && e.push(r);\n  return e;\n}\nfunction p(t, e) {\n  e !== s && t.push(e);\n}\nconst w = t => u(\"and\", t),\n  b = t => u(\"or\", t),\n  O = {\n    compound(t, e, n) {\n      const o = (Array.isArray(e) ? e : [e]).map(t => n.parse(t));\n      return new r(t.name, o);\n    },\n    field: (t, e, r) => new o(t.name, r.field, e),\n    document: (t, r) => new e(t.name, r)\n  };\nclass j {\n  constructor(t) {\n    let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : h();\n    this.o = void 0, this.s = void 0, this.i = void 0, this.u = void 0, this.h = void 0, this.parse = this.parse.bind(this), this.u = {\n      operatorToConditionName: e.operatorToConditionName || a,\n      defaultOperatorName: e.defaultOperatorName || \"eq\",\n      mergeFinalConditions: e.mergeFinalConditions || w\n    }, this.o = Object.keys(t).reduce((e, r) => (e[r] = Object.assign({\n      name: this.u.operatorToConditionName(r)\n    }, t[r]), e), {}), this.s = Object.assign({}, e.fieldContext, {\n      field: \"\",\n      query: {},\n      parse: this.parse,\n      hasOperators: t => l(t, this.o, e.useIgnoreValue)\n    }), this.i = Object.assign({}, e.documentContext, {\n      parse: this.parse,\n      query: {}\n    }), this.h = e.useIgnoreValue ? d : Object.keys;\n  }\n  setParse(t) {\n    this.parse = t, this.s.parse = t, this.i.parse = t;\n  }\n  parseField(t, e, r, n) {\n    const o = this.o[e];\n    if (!o) throw new Error(`Unsupported operator \"${e}\"`);\n    if (\"field\" !== o.type) throw new Error(`Unexpected ${o.type} operator \"${e}\" at field level`);\n    return this.s.field = t, this.s.query = n, this.parseInstruction(o, r, this.s);\n  }\n  parseInstruction(t, e, r) {\n    \"function\" == typeof t.validate && t.validate(t, e);\n    return (t.parse || O[t.type])(t, e, r);\n  }\n  parseFieldOperators(t, e) {\n    const r = [],\n      n = this.h(e);\n    for (let o = 0, s = n.length; o < s; o++) {\n      const s = n[o];\n      if (!this.o[s]) throw new Error(`Field query for \"${t}\" may contain only operators or a plain object as a value`);\n      p(r, this.parseField(t, s, e[s], e));\n    }\n    return r;\n  }\n  parse(t) {\n    const e = [],\n      r = this.h(t);\n    this.i.query = t;\n    for (let n = 0, o = r.length; n < o; n++) {\n      const o = r[n],\n        s = t[o],\n        i = this.o[o];\n      if (i) {\n        if (\"document\" !== i.type && \"compound\" !== i.type) throw new Error(`Cannot use parsing instruction for operator \"${o}\" in \"document\" context as it is supposed to be used in  \"${i.type}\" context`);\n        p(e, this.parseInstruction(i, s, this.i));\n      } else this.s.hasOperators(s) ? e.push(...this.parseFieldOperators(o, s)) : p(e, this.parseField(o, this.u.defaultOperatorName, s, t));\n    }\n    return this.u.mergeFinalConditions(e);\n  }\n}\nfunction _(t, e) {\n  const r = t[e];\n  if (\"function\" != typeof r) throw new Error(`Unable to interpret \"${e}\" condition. Did you forget to register interpreter for it?`);\n  return r;\n}\nfunction y(t) {\n  return t.operator;\n}\nfunction m(t, e) {\n  const r = e,\n    n = r && r.getInterpreterName || y;\n  let o;\n  switch (r ? r.numberOfArguments : 0) {\n    case 1:\n      o = e => {\n        const o = n(e, r);\n        return _(t, o)(e, s);\n      };\n      break;\n    case 3:\n      o = (e, o, i) => {\n        const c = n(e, r);\n        return _(t, c)(e, o, i, s);\n      };\n      break;\n    default:\n      o = (e, o) => {\n        const i = n(e, r);\n        return _(t, i)(e, o, s);\n      };\n  }\n  const s = Object.assign({}, r, {\n    interpret: o\n  });\n  return s.interpret;\n}\nfunction v(t, e) {\n  return function (r) {\n    for (var _len = arguments.length, n = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      n[_key - 1] = arguments[_key];\n    }\n    const o = t(r, ...n),\n      s = e.bind(null, o);\n    return s.ast = o, s;\n  };\n}\nconst x = j.prototype.parseInstruction;\nexport { r as CompoundCondition, t as Condition, e as DocumentCondition, o as FieldCondition, n as ITSELF, s as NULL_CONDITION, j as ObjectQueryParser, w as buildAnd, b as buildOr, m as createInterpreter, v as createTranslatorFactory, O as defaultInstructionParsers, l as hasOperators, a as identity, f as ignoreValue, c as isCompound, h as object, u as optimizedCompoundCondition, x as parseInstruction };","map":{"version":3,"names":["t","constructor","e","operator","value","Object","defineProperty","writable","notes","addNote","push","r","Array","isArray","Error","n","o","field","s","i","prototype","hasOwnProperty","call","bind","c","u","length","a","h","object","create","f","l","arguments","undefined","d","p","w","b","O","compound","map","parse","name","document","j","operatorToConditionName","defaultOperatorName","mergeFinalConditions","keys","reduce","assign","fieldContext","query","hasOperators","useIgnoreValue","documentContext","setParse","parseField","type","parseInstruction","validate","parseFieldOperators","_","y","m","getInterpreterName","numberOfArguments","interpret","v","_len","_key","ast","x","CompoundCondition","Condition","DocumentCondition","FieldCondition","ITSELF","NULL_CONDITION","ObjectQueryParser","buildAnd","buildOr","createInterpreter","createTranslatorFactory","defaultInstructionParsers","identity","ignoreValue","isCompound","optimizedCompoundCondition"],"sources":["/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@ucast/core/src/Condition.ts","/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@ucast/core/src/utils.ts","/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@ucast/core/src/builder.ts","/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@ucast/core/src/parsers/defaultInstructionParsers.ts","/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@ucast/core/src/parsers/ObjectQueryParser.ts","/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@ucast/core/src/interpreter.ts","/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@ucast/core/src/translator.ts","/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@ucast/core/src/index.ts"],"sourcesContent":["export interface Note<T> {\n  type: string\n  message?: string\n  originalValue?: T\n}\n\nexport abstract class Condition<T = unknown> {\n  private _notes!: Note<T>[];\n\n  constructor(\n    public readonly operator: string,\n    public readonly value: T\n  ) {\n    Object.defineProperty(this, '_notes', {\n      writable: true\n    });\n  }\n\n  get notes(): ReadonlyArray<Note<T>> | undefined {\n    return this._notes;\n  }\n\n  addNote(note: Note<T>) {\n    this._notes = this._notes || [];\n    this._notes.push(note);\n  }\n}\n\nexport class DocumentCondition<T> extends Condition<T> {\n}\n\nexport class CompoundCondition<T extends Condition = Condition> extends DocumentCondition<T[]> {\n  constructor(operator: string, conditions: T[]) {\n    if (!Array.isArray(conditions)) {\n      throw new Error(`\"${operator}\" operator expects to receive an array of conditions`);\n    }\n\n    super(operator, conditions);\n  }\n}\n\nexport const ITSELF = '__itself__';\nexport class FieldCondition<T = unknown> extends Condition<T> {\n  public readonly field!: string | typeof ITSELF;\n\n  constructor(operator: string, field: string | typeof ITSELF, value: T) {\n    super(operator, value);\n    this.field = field;\n  }\n}\n\nexport const NULL_CONDITION = new DocumentCondition('__null__', null);\nexport type ConditionValue<T> = T extends Condition<infer V> ? V : unknown;\n","import { Condition, CompoundCondition, NULL_CONDITION } from './Condition';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n\nexport function isCompound(operator: string, condition: Condition): condition is CompoundCondition {\n  return condition instanceof CompoundCondition && condition.operator === operator;\n}\n\nfunction flattenConditions<T extends Condition>(\n  operator: string,\n  conditions: T[],\n  aggregatedResult?: T[]\n) {\n  const flatConditions: T[] = aggregatedResult || [];\n\n  for (let i = 0, length = conditions.length; i < length; i++) {\n    const currentNode = conditions[i];\n\n    if (isCompound(operator, currentNode)) {\n      flattenConditions(operator, currentNode.value as T[], flatConditions);\n    } else {\n      flatConditions.push(currentNode);\n    }\n  }\n\n  return flatConditions;\n}\n\nexport function optimizedCompoundCondition<T extends Condition>(operator: string, conditions: T[]) {\n  if (conditions.length === 1) {\n    return conditions[0];\n  }\n\n  return new CompoundCondition(operator, flattenConditions(operator, conditions));\n}\n\nexport const identity = <T>(x: T) => x;\nexport const object = () => Object.create(null);\n\nexport const ignoreValue: IgnoreValue = Object.defineProperty(object(), '__@type@__', {\n  value: 'ignore value'\n});\nexport interface IgnoreValue {\n  readonly ['__@type@__']: 'ignore value'\n}\n\nexport function hasOperators<T>(\n  value: any,\n  instructions: Record<string, unknown>,\n  skipIgnore = false,\n): value is T {\n  if (!value || value && value.constructor !== Object) {\n    return false;\n  }\n\n  for (const prop in value) { // eslint-disable-line no-restricted-syntax, guard-for-in\n    const hasProp = hasOwnProperty(value, prop) && hasOwnProperty(instructions, prop);\n    if (hasProp && (!skipIgnore || value[prop] !== ignoreValue)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function objectKeysSkipIgnore(anyObject: Record<string, unknown>) {\n  const keys: string[] = [];\n  for (const key in anyObject) { // eslint-disable-line no-restricted-syntax\n    if (hasOwnProperty(anyObject, key) && anyObject[key] !== ignoreValue) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n}\n\nexport function pushIfNonNullCondition(conditions: Condition[], condition: Condition) {\n  if (condition !== NULL_CONDITION) {\n    conditions.push(condition);\n  }\n}\n","import { Condition } from './Condition';\nimport { optimizedCompoundCondition } from './utils';\n\nexport const buildAnd = (conditions: Condition[]) => optimizedCompoundCondition('and', conditions);\nexport const buildOr = (conditions: Condition[]) => optimizedCompoundCondition('or', conditions);\n","import {\n  FieldCondition,\n  CompoundCondition,\n  DocumentCondition,\n} from '../Condition';\nimport {\n  DocumentInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n} from '../types';\n\ninterface DefaultParsers {\n  compound: Exclude<CompoundInstruction['parse'], undefined>,\n  field: Exclude<FieldInstruction['parse'], undefined>,\n  document: Exclude<DocumentInstruction['parse'], undefined>\n}\n\nexport const defaultInstructionParsers: DefaultParsers = {\n  compound(instruction, value, context) {\n    const queries = Array.isArray(value) ? value : [value];\n    const conditions = queries.map(query => context.parse(query));\n    return new CompoundCondition(instruction.name, conditions);\n  },\n  field(instruction, value, context) {\n    return new FieldCondition(instruction.name, context.field, value);\n  },\n  document(instruction, value) {\n    return new DocumentCondition(instruction.name, value);\n  }\n};\n","import { Condition } from '../Condition';\nimport {\n  NamedInstruction,\n  ParsingInstruction,\n  FieldParsingContext,\n  ParsingContext,\n} from '../types';\nimport { buildAnd } from '../builder';\nimport { defaultInstructionParsers } from './defaultInstructionParsers';\nimport {\n  identity,\n  hasOperators,\n  object,\n  pushIfNonNullCondition,\n  objectKeysSkipIgnore,\n} from '../utils';\n\nexport type FieldQueryOperators<T extends {}> = {\n  [K in keyof T]: T[K] extends {} ? T[K] : never\n}[keyof T];\n\ntype ParsingInstructions = Record<string, NamedInstruction>;\n\nexport interface QueryOptions {\n  operatorToConditionName?(name: string): string\n  defaultOperatorName?: string\n  fieldContext?: Record<string, unknown>\n  documentContext?: Record<string, unknown>\n  useIgnoreValue?: boolean\n  mergeFinalConditions?(conditions: Condition[]): Condition\n}\n\nexport type ObjectQueryFieldParsingContext = ParsingContext<FieldParsingContext & {\n  query: {},\n  hasOperators<T>(value: unknown): value is T\n}>;\n\nexport class ObjectQueryParser<\n  T extends Record<any, any>,\n  U extends FieldQueryOperators<T> = FieldQueryOperators<T>\n> {\n  private readonly _instructions: ParsingInstructions;\n  private _fieldInstructionContext: ObjectQueryFieldParsingContext;\n  private _documentInstructionContext: ParsingContext<{ query: {} }>;\n  private readonly _options: Required<\n  Pick<QueryOptions, 'operatorToConditionName' | 'defaultOperatorName' | 'mergeFinalConditions'>\n  >;\n\n  private readonly _objectKeys: typeof Object.keys;\n\n  constructor(instructions: Record<string, ParsingInstruction>, options: QueryOptions = object()) {\n    this.parse = this.parse.bind(this);\n    this._options = {\n      operatorToConditionName: options.operatorToConditionName || identity,\n      defaultOperatorName: options.defaultOperatorName || 'eq',\n      mergeFinalConditions: options.mergeFinalConditions || buildAnd,\n    };\n    this._instructions = Object.keys(instructions).reduce((all, name) => {\n      all[name] = { name: this._options.operatorToConditionName(name), ...instructions[name] };\n      return all;\n    }, {} as ParsingInstructions);\n    this._fieldInstructionContext = {\n      ...options.fieldContext,\n      field: '',\n      query: {},\n      parse: this.parse,\n      hasOperators: <T>(value: unknown): value is T => hasOperators(\n        value,\n        this._instructions,\n        options.useIgnoreValue\n      ),\n    };\n    this._documentInstructionContext = {\n      ...options.documentContext,\n      parse: this.parse,\n      query: {}\n    };\n    this._objectKeys = options.useIgnoreValue ? objectKeysSkipIgnore : Object.keys;\n  }\n\n  setParse(parse: this['parse']) {\n    this.parse = parse;\n    this._fieldInstructionContext.parse = parse;\n    this._documentInstructionContext.parse = parse;\n  }\n\n  protected parseField(field: string, operator: string, value: unknown, parentQuery: {}) {\n    const instruction = this._instructions[operator];\n\n    if (!instruction) {\n      throw new Error(`Unsupported operator \"${operator}\"`);\n    }\n\n    if (instruction.type !== 'field') {\n      throw new Error(`Unexpected ${instruction.type} operator \"${operator}\" at field level`);\n    }\n\n    this._fieldInstructionContext.field = field;\n    this._fieldInstructionContext.query = parentQuery;\n\n    return this.parseInstruction(instruction, value, this._fieldInstructionContext);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  protected parseInstruction(\n    instruction: NamedInstruction,\n    value: unknown,\n    context: ParsingContext<{}>\n  ) {\n    if (typeof instruction.validate === 'function') {\n      instruction.validate(instruction, value);\n    }\n\n    const parse: typeof instruction.parse = instruction.parse\n      || defaultInstructionParsers[instruction.type as keyof typeof defaultInstructionParsers];\n    return parse(instruction, value, context);\n  }\n\n  protected parseFieldOperators(field: string, value: U) {\n    const conditions: Condition[] = [];\n    const keys = this._objectKeys(value);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const op = keys[i];\n      const instruction = this._instructions[op];\n\n      if (!instruction) {\n        throw new Error(`Field query for \"${field}\" may contain only operators or a plain object as a value`);\n      }\n\n      const condition = this.parseField(field, op, value[op as keyof U], value);\n      pushIfNonNullCondition(conditions, condition);\n    }\n\n    return conditions;\n  }\n\n  parse<Q extends T>(query: Q): Condition {\n    const conditions = [];\n    const keys = this._objectKeys(query);\n\n    this._documentInstructionContext.query = query;\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      const value = query[key];\n      const instruction = this._instructions[key];\n\n      if (instruction) {\n        if (instruction.type !== 'document' && instruction.type !== 'compound') {\n          throw new Error(`Cannot use parsing instruction for operator \"${key}\" in \"document\" context as it is supposed to be used in  \"${instruction.type}\" context`);\n        }\n\n        pushIfNonNullCondition(\n          conditions,\n          this.parseInstruction(instruction, value, this._documentInstructionContext)\n        );\n      } else if (this._fieldInstructionContext.hasOperators<U>(value)) {\n        conditions.push(...this.parseFieldOperators(key, value));\n      } else {\n        pushIfNonNullCondition(\n          conditions,\n          this.parseField(key, this._options.defaultOperatorName, value, query)\n        );\n      }\n    }\n\n    return this._options.mergeFinalConditions(conditions);\n  }\n}\n","import { Condition } from './Condition';\n\ntype ArgsExceptLast<F extends (...args: any[]) => any> =\n  F extends (a: any, c: any) => any\n    ? Parameters<(condition: Condition) => 0>\n    : F extends (a: any, b: any, c: any) => any\n      ? Parameters<(condition: Condition, value: Parameters<F>[1]) => 0>\n      : Parameters<(\n        condition: Condition,\n        value: Parameters<F>[1],\n        options: Parameters<F>[2],\n        ...args: unknown[]\n      ) => 0>;\n\nexport type Interpreter<T extends Condition, R> = (condition: T, ...args: any[]) => R;\nexport type AnyInterpreter = Interpreter<any, any>;\nexport interface InterpretationContext<T extends AnyInterpreter> {\n  interpret(...args: ArgsExceptLast<T>): ReturnType<T>;\n}\n\nfunction getInterpreter<T extends Record<string, AnyInterpreter>>(\n  interpreters: T,\n  operator: keyof T\n) {\n  const interpret = interpreters[operator];\n\n  if (typeof interpret !== 'function') {\n    throw new Error(`Unable to interpret \"${operator}\" condition. Did you forget to register interpreter for it?`);\n  }\n\n  return interpret;\n}\n\nexport interface InterpreterOptions {\n  numberOfArguments?: 1 | 2 | 3\n  getInterpreterName?(condition: Condition, context: this): string\n}\n\nfunction defaultInterpreterName(condition: Condition) {\n  return condition.operator;\n}\n\nexport function createInterpreter<T extends AnyInterpreter, U extends {} = {}>(\n  interpreters: Record<string, T>,\n  rawOptions?: U\n) {\n  const options = rawOptions as U & InterpreterOptions;\n  const getInterpreterName = options && options.getInterpreterName || defaultInterpreterName;\n  let interpret;\n\n  switch (options ? options.numberOfArguments : 0) {\n    case 1:\n      interpret = ((condition) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    case 3:\n      interpret = ((condition, value, params) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, params, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    default:\n      interpret = ((condition, value) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n  }\n\n  const defaultContext = {\n    ...options,\n    interpret,\n  } as InterpretationContext<T> & U;\n\n  return defaultContext.interpret;\n}\n","import { Condition } from './Condition';\nimport { Parse } from './types';\nimport { AnyInterpreter } from './interpreter';\n\ntype Bound<T> = T extends (first: Condition, ...args: infer A) => any\n  ? { (...args: A): ReturnType<T>, ast: Condition }\n  : never;\n\nexport function createTranslatorFactory<Lang, Interpreter extends AnyInterpreter>(\n  parse: Parse<Lang>,\n  interpret: Interpreter\n) {\n  return (query: Lang, ...args: unknown[]): Bound<Interpreter> => {\n    const ast = parse(query, ...args);\n    const translate = (interpret as any).bind(null, ast);\n    translate.ast = ast;\n    return translate;\n  };\n}\n","import { ObjectQueryParser } from './parsers/ObjectQueryParser';\n\nexport * from './Condition';\nexport * from './types';\nexport * from './interpreter';\nexport * from './translator';\nexport * from './builder';\nexport {\n  isCompound,\n  hasOperators,\n  identity,\n  object,\n  optimizedCompoundCondition,\n  ignoreValue,\n} from './utils';\nexport type {\n  IgnoreValue\n} from './utils';\nexport * from './parsers/ObjectQueryParser';\nexport * from './parsers/defaultInstructionParsers';\n/**\n * @deprecated use `ObjectQueryParser#parseInstruction` instead\n * TODO(major): remove\n */\nexport const parseInstruction = (ObjectQueryParser.prototype as any).parseInstruction;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}