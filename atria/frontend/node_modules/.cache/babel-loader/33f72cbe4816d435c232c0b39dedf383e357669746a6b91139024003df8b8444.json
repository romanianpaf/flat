{"ast":null,"code":"import { createTranslatorFactory as o, ITSELF as t } from \"@ucast/core\";\nexport * from \"@ucast/core\";\nimport { MongoQueryParser as r, allParsingInstructions as e, defaultParsers as c } from \"@ucast/mongo\";\nexport * from \"@ucast/mongo\";\nimport { createJsInterpreter as n, allInterpreters as f, compare as s } from \"@ucast/js\";\nexport * from \"@ucast/js\";\nfunction i(o) {\n  return o instanceof Date ? o.getTime() : o && \"function\" == typeof o.toJSON ? o.toJSON() : o;\n}\nvar m = function m(o, t) {\n  return s(i(o), i(t));\n};\nfunction p(e, c, f) {\n  var s = new r(e),\n    i = n(c, Object.assign({\n      compare: m\n    }, f));\n  if (f && f.forPrimitives) {\n    var _o = {\n        field: t\n      },\n      _r = s.parse;\n    s.setParse(function (t) {\n      return _r(t, _o);\n    });\n  }\n  return o(s.parse, i);\n}\nvar a = p(e, f),\n  u = p([\"$and\", \"$or\"].reduce(function (o, t) {\n    return o[t] = Object.assign({}, o[t], {\n      type: \"field\"\n    }), o;\n  }, Object.assign({}, e, {\n    $nor: Object.assign({}, e.$nor, {\n      type: \"field\",\n      parse: c.compound\n    })\n  })), f, {\n    forPrimitives: !0\n  }),\n  j = a;\nexport { p as createFactory, j as filter, a as guard, u as squire };","map":{"version":3,"names":["i","o","Date","getTime","toJSON","m","t","s","p","e","c","f","r","n","Object","assign","compare","forPrimitives","field","parse","setParse","a","u","reduce","type","$nor","compound","j","createFactory","filter","guard","squire"],"sources":["/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@ucast/mongo2js/src/factory.ts"],"sourcesContent":["import { createTranslatorFactory, ParsingInstruction, Condition, ITSELF } from '@ucast/core';\nimport {\n  MongoQuery,\n  MongoQueryParser,\n  MongoQueryFieldOperators,\n  allParsingInstructions,\n  defaultParsers\n} from '@ucast/mongo';\nimport {\n  createJsInterpreter,\n  allInterpreters,\n  JsInterpreter,\n  JsInterpretationOptions,\n  compare\n} from '@ucast/js';\n\ntype ThingFilter<T> = {\n  (object: T): boolean\n  ast: Condition\n};\n\ninterface HasToJSON {\n  toJSON(): unknown\n}\n\nfunction toPrimitive(value: unknown) {\n  if (value instanceof Date) {\n    return value.getTime();\n  }\n\n  if (value && typeof (value as HasToJSON).toJSON === 'function') {\n    return (value as HasToJSON).toJSON();\n  }\n\n  return value;\n}\n\nconst comparePrimitives: typeof compare = (a, b) => compare(toPrimitive(a), toPrimitive(b));\n\nexport interface FactoryOptions extends JsInterpretationOptions {\n  forPrimitives: boolean\n}\n\nexport type Filter = <\n  T = Record<string, unknown>,\n  Q extends MongoQuery<T> = MongoQuery<T>\n>(query: Q) => ThingFilter<T>;\n\nexport type PrimitiveMongoQuery<T> = MongoQueryFieldOperators<T> & Partial<{\n  $and: MongoQueryFieldOperators<T>[],\n  $or: MongoQueryFieldOperators<T>[],\n  $nor: MongoQueryFieldOperators<T>[]\n}>;\nexport type PrimitiveFilter = <\n  T,\n  Q extends PrimitiveMongoQuery<T> = PrimitiveMongoQuery<T>\n>(query: Q) => ThingFilter<T>;\n\ntype FilterType<T extends { forPrimitives?: true }> = T['forPrimitives'] extends true\n  ? PrimitiveFilter\n  : Filter;\n\nexport function createFactory<\n  T extends Record<string, ParsingInstruction<any, any>>,\n  I extends Record<string, JsInterpreter<any>>,\n  P extends { forPrimitives?: true }\n>(instructions: T, interpreters: I, options?: Partial<FactoryOptions> & P): FilterType<P> {\n  const parser = new MongoQueryParser(instructions);\n  const interpret = createJsInterpreter(interpreters, {\n    compare: comparePrimitives,\n    ...options\n  });\n\n  if (options && options.forPrimitives) {\n    const params = { field: ITSELF };\n    const parse = parser.parse;\n    parser.setParse(query => parse(query, params));\n  }\n\n  return createTranslatorFactory(parser.parse, interpret) as any;\n}\n\nexport const guard = createFactory(allParsingInstructions, allInterpreters);\n\nconst compoundOperators = ['$and', '$or'] as const;\nconst allPrimitiveParsingInstructions = compoundOperators.reduce((instructions, name) => {\n  instructions[name] = { ...instructions[name], type: 'field' } as any;\n  return instructions;\n}, {\n  ...allParsingInstructions,\n  $nor: {\n    ...allParsingInstructions.$nor,\n    type: 'field',\n    parse: defaultParsers.compound\n  }\n});\n\nexport const squire = createFactory(allPrimitiveParsingInstructions, allInterpreters, {\n  forPrimitives: true\n});\nexport const filter = guard; // TODO: remove in next major version\n"],"mappings":";;;;;;AAyBA,SAASA,EAAYC,CAAA;EAAA,OACfA,CAAA,YAAiBC,IAAA,GACZD,CAAA,CAAME,OAAA,KAGXF,CAAA,IAAgD,qBAA/BA,CAAA,CAAoBG,MAAA,GAC/BH,CAAA,CAAoBG,MAAA,KAGvBH,CAAA;AAAA;AAGT,IAAMI,CAAA,GAAoC,SAApCA,EAAqCJ,CAAA,EAAGK,CAAA;EAAA,OAAMC,CAAA,CAAQP,CAAA,CAAYC,CAAA,GAAID,CAAA,CAAYM,CAAA;AAAA;AAyBjF,SAASE,EAIdC,CAAA,EAAiBC,CAAA,EAAiBC,CAAA;EAAA,IAC5BJ,CAAA,GAAS,IAAIK,CAAA,CAAiBH,CAAA;IAC9BT,CAAA,GAAYa,CAAA,CAAoBH,CAAA,EAAAI,MAAA,CAAAC,MAAA;MACpCC,OAAA,EAASX;IAAA,GACNM,CAAA;EAAA,IAGDA,CAAA,IAAWA,CAAA,CAAQM,aAAA,EAAe;IAAA,IAC9BhB,EAAA,GAAS;QAAEiB,KAAA,EAAOZ;MAAA;MAClBM,EAAA,GAAQL,CAAA,CAAOY,KAAA;IACrBZ,CAAA,CAAOa,QAAA,CAAS,UAAAd,CAAA;MAAA,OAASM,EAAA,CAAMN,CAAA,EAAOL,EAAA;IAAA;EAAA;EAAA,OAGjCA,CAAA,CAAwBM,CAAA,CAAOY,KAAA,EAAOnB,CAAA;AAAA;AAAA,IAGlCqB,CAAA,GAAQb,CAAA,CAAcC,CAAA,EAAwBE,CAAA;EAe9CW,CAAA,GAASd,CAAA,CAbI,CAAC,QAAQ,OACuBe,MAAA,CAAO,UAACtB,CAAA,EAAcK,CAAA;IAAA,OAC9EL,CAAA,CAAaK,CAAA,IAAAQ,MAAA,CAAAC,MAAA,KAAad,CAAA,CAAaK,CAAA;MAAOkB,IAAA,EAAM;IAAA,IAC7CvB,CAAA;EAAA,GAAAa,MAAA,CAAAC,MAAA,KAEJN,CAAA;IACHgB,IAAA,EAAAX,MAAA,CAAAC,MAAA,KACKN,CAAA,CAAuBgB,IAAA;MAC1BD,IAAA,EAAM;MACNL,KAAA,EAAOT,CAAA,CAAegB;IAAA;EAAA,KAI2Cf,CAAA,EAAiB;IACpFM,aAAA,GAAe;EAAA;EAEJU,CAAA,GAASN,CAAA;AAAA,SAAAb,CAAA,IAAAoB,aAAA,EAAAD,CAAA,IAAAE,MAAA,EAAAR,CAAA,IAAAS,KAAA,EAAAR,CAAA,IAAAS,MAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}