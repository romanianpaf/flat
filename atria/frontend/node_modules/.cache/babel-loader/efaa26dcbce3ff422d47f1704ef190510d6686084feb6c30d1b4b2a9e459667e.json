{"ast":null,"code":"import { createFactory as t, $eq as e, $ne as i, $lt as s, $lte as n, $gt as r, $gte as o, $in as c, $nin as u, $all as h, $size as l, $regex as a, $options as f, $elemMatch as d, $exists as y, eq as b, ne as p, lt as w, lte as g, gt as $, gte as A, within as j, nin as M, all as m, size as E, regex as v, elemMatch as x, exists as F, and as _ } from \"@ucast/mongo2js\";\nfunction O(t) {\n  return Array.isArray(t) ? t : [t];\n}\nconst C = Object.hasOwn || Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\nconst R = \"__caslSubjectType__\";\nfunction P(t, e) {\n  if (e) if (!C(e, R)) Object.defineProperty(e, R, {\n    value: t\n  });else if (t !== e[R]) throw new Error(`Trying to cast object to subject type ${t} but previously it was casted to ${e[R]}`);\n  return e;\n}\nconst S = t => {\n  const e = typeof t;\n  return \"string\" === e || \"function\" === e;\n};\nconst T = t => t.modelName || t.name;\nconst B = t => \"string\" === typeof t ? t : T(t);\nfunction q(t) {\n  if (C(t, R)) return t[R];\n  return T(t.constructor);\n}\nfunction z(t, e, i) {\n  let s = O(e);\n  let n = 0;\n  while (n < s.length) {\n    const e = s[n++];\n    if (C(t, e)) s = i(s, t[e]);\n  }\n  return s;\n}\nfunction D(t, e) {\n  if (\"string\" === typeof e && -1 !== t.indexOf(e)) return e;\n  for (let i = 0; i < e.length; i++) if (-1 !== t.indexOf(e[i])) return e[i];\n  return null;\n}\nconst Y = (t, e) => t.concat(e);\nfunction k(t, e) {\n  if (e in t) throw new Error(`Cannot use \"${e}\" as an alias because it's reserved action.`);\n  const i = Object.keys(t);\n  const s = (t, i) => {\n    const s = D(t, i);\n    if (s) throw new Error(`Detected cycle ${s} -> ${t.join(\", \")}`);\n    const n = \"string\" === typeof i && i === e || -1 !== t.indexOf(e) || Array.isArray(i) && -1 !== i.indexOf(e);\n    if (n) throw new Error(`Cannot make an alias to \"${e}\" because this is reserved action`);\n    return t.concat(i);\n  };\n  for (let e = 0; e < i.length; e++) z(t, i[e], s);\n}\nfunction I(t, e) {\n  if (!e || false !== e.skipValidate) k(t, e && e.anyAction || \"manage\");\n  return e => z(t, e, Y);\n}\nfunction L(t, e, i) {\n  for (let s = i; s < e.length; s++) t.push(e[s]);\n}\nfunction U(t, e) {\n  if (!t || !t.length) return e || [];\n  if (!e || !e.length) return t || [];\n  let i = 0;\n  let s = 0;\n  const n = [];\n  while (i < t.length && s < e.length) if (t[i].priority < e[s].priority) {\n    n.push(t[i]);\n    i++;\n  } else {\n    n.push(e[s]);\n    s++;\n  }\n  L(n, t, i);\n  L(n, e, s);\n  return n;\n}\nfunction G(t, e, i) {\n  let s = t.get(e);\n  if (!s) {\n    s = i();\n    t.set(e, s);\n  }\n  return s;\n}\nconst H = t => t;\nfunction J(t, e) {\n  if (Array.isArray(t.fields) && !t.fields.length) throw new Error(\"`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa\");\n  if (t.fields && !e.fieldMatcher) throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');\n  if (t.conditions && !e.conditionsMatcher) throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions');\n}\nclass K {\n  constructor(t, e, i = 0) {\n    J(t, e);\n    this.action = e.resolveAction(t.action);\n    this.subject = t.subject;\n    this.inverted = !!t.inverted;\n    this.conditions = t.conditions;\n    this.reason = t.reason;\n    this.origin = t;\n    this.fields = t.fields ? O(t.fields) : void 0;\n    this.priority = i;\n    this.t = e;\n  }\n  i() {\n    if (this.conditions && !this.o) this.o = this.t.conditionsMatcher(this.conditions);\n    return this.o;\n  }\n  get ast() {\n    const t = this.i();\n    return t ? t.ast : void 0;\n  }\n  matchesConditions(t) {\n    if (!this.conditions) return true;\n    if (!t || S(t)) return !this.inverted;\n    const e = this.i();\n    return e(t);\n  }\n  matchesField(t) {\n    if (!this.fields) return true;\n    if (!t) return !this.inverted;\n    if (this.fields && !this.u) this.u = this.t.fieldMatcher(this.fields);\n    return this.u(t);\n  }\n}\nfunction N(t, e) {\n  const i = {\n    value: t,\n    prev: e,\n    next: null\n  };\n  if (e) e.next = i;\n  return i;\n}\nfunction Q(t) {\n  if (t.next) t.next.prev = t.prev;\n  if (t.prev) t.prev.next = t.next;\n  t.next = t.prev = null;\n}\nconst V = t => ({\n  value: t.value,\n  prev: t.prev,\n  next: t.next\n});\nconst W = () => ({\n  rules: [],\n  merged: false\n});\nconst X = () => new Map();\nclass Z {\n  constructor(t = [], e = {}) {\n    this.h = false;\n    this.l = {\n      conditionsMatcher: e.conditionsMatcher,\n      fieldMatcher: e.fieldMatcher,\n      resolveAction: e.resolveAction || H\n    };\n    this.p = e.anyAction || \"manage\";\n    this.g = e.anySubjectType || \"all\";\n    this.$ = e.detectSubjectType || q;\n    this.A = t;\n    this.j = this.M(t);\n  }\n  get rules() {\n    return this.A;\n  }\n  detectSubjectType(t) {\n    if (S(t)) return t;\n    if (!t) return this.g;\n    return this.$(t);\n  }\n  update(t) {\n    const e = {\n      rules: t,\n      ability: this,\n      target: this\n    };\n    this.m(\"update\", e);\n    this.A = t;\n    this.j = this.M(t);\n    this.m(\"updated\", e);\n    return this;\n  }\n  M(t) {\n    const e = new Map();\n    for (let i = t.length - 1; i >= 0; i--) {\n      const s = t.length - i - 1;\n      const n = new K(t[i], this.l, s);\n      const r = O(n.action);\n      const o = O(n.subject || this.g);\n      if (!this.h && n.fields) this.h = true;\n      for (let t = 0; t < o.length; t++) {\n        const i = G(e, o[t], X);\n        for (let t = 0; t < r.length; t++) G(i, r[t], W).rules.push(n);\n      }\n    }\n    return e;\n  }\n  possibleRulesFor(t, e = this.g) {\n    if (!S(e)) throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');\n    const i = G(this.j, e, X);\n    const s = G(i, t, W);\n    if (s.merged) return s.rules;\n    const n = t !== this.p && i.has(this.p) ? i.get(this.p).rules : void 0;\n    let r = U(s.rules, n);\n    if (e !== this.g) r = U(r, this.possibleRulesFor(t, this.g));\n    s.rules = r;\n    s.merged = true;\n    return r;\n  }\n  rulesFor(t, e, i) {\n    const s = this.possibleRulesFor(t, e);\n    if (i && \"string\" !== typeof i) throw new Error(\"The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details\");\n    if (!this.h) return s;\n    return s.filter(t => t.matchesField(i));\n  }\n  actionsFor(t) {\n    if (!S(t)) throw new Error('\"actionsFor\" accepts only subject types (i.e., string or class) as a parameter');\n    const e = new Set();\n    const i = this.j.get(t);\n    if (i) Array.from(i.keys()).forEach(t => e.add(t));\n    const s = t !== this.g ? this.j.get(this.g) : void 0;\n    if (s) Array.from(s.keys()).forEach(t => e.add(t));\n    return Array.from(e);\n  }\n  on(t, e) {\n    this.v = this.v || new Map();\n    const i = this.v;\n    const s = i.get(t) || null;\n    const n = N(e, s);\n    i.set(t, n);\n    return () => {\n      const e = i.get(t);\n      if (!n.next && !n.prev && e === n) i.delete(t);else if (n === e) i.set(t, n.prev);\n      Q(n);\n    };\n  }\n  m(t, e) {\n    if (!this.v) return;\n    let i = this.v.get(t) || null;\n    while (null !== i) {\n      const t = i.prev ? V(i.prev) : null;\n      i.value(e);\n      i = t;\n    }\n  }\n}\nclass PureAbility extends Z {\n  can(t, e, i) {\n    const s = this.relevantRuleFor(t, e, i);\n    return !!s && !s.inverted;\n  }\n  relevantRuleFor(t, e, i) {\n    const s = this.detectSubjectType(e);\n    const n = this.rulesFor(t, s, i);\n    for (let t = 0, i = n.length; t < i; t++) if (n[t].matchesConditions(e)) return n[t];\n    return null;\n  }\n  cannot(t, e, i) {\n    return !this.can(t, e, i);\n  }\n}\nconst tt = {\n  $eq: e,\n  $ne: i,\n  $lt: s,\n  $lte: n,\n  $gt: r,\n  $gte: o,\n  $in: c,\n  $nin: u,\n  $all: h,\n  $size: l,\n  $regex: a,\n  $options: f,\n  $elemMatch: d,\n  $exists: y\n};\nconst et = {\n  eq: b,\n  ne: p,\n  lt: w,\n  lte: g,\n  gt: $,\n  gte: A,\n  in: j,\n  nin: M,\n  all: m,\n  size: E,\n  regex: v,\n  elemMatch: x,\n  exists: F,\n  and: _\n};\nconst it = (e, i, s) => t(Object.assign({}, tt, e), Object.assign({}, et, i), s);\nconst st = t(tt, et);\nconst nt = /[-/\\\\^$+?.()|[\\]{}]/g;\nconst rt = /\\.?\\*+\\.?/g;\nconst ot = /\\*+/;\nconst ct = /\\./g;\nfunction ut(t, e, i) {\n  const s = \"*\" === i[0] || \".\" === t[0] && \".\" === t[t.length - 1] ? \"+\" : \"*\";\n  const n = -1 === t.indexOf(\"**\") ? \"[^.]\" : \".\";\n  const r = t.replace(ct, \"\\\\$&\").replace(ot, n + s);\n  return e + t.length === i.length ? `(?:${r})?` : r;\n}\nfunction ht(t, e, i) {\n  if (\".\" === t && (\"*\" === i[e - 1] || \"*\" === i[e + 1])) return t;\n  return `\\\\${t}`;\n}\nfunction lt(t) {\n  const e = t.map(t => t.replace(nt, ht).replace(rt, ut));\n  const i = e.length > 1 ? `(?:${e.join(\"|\")})` : e[0];\n  return new RegExp(`^${i}$`);\n}\nconst at = t => {\n  let e;\n  return i => {\n    if (\"undefined\" === typeof e) e = t.every(t => -1 === t.indexOf(\"*\")) ? null : lt(t);\n    return null === e ? -1 !== t.indexOf(i) : e.test(i);\n  };\n};\nclass Ability extends PureAbility {\n  constructor(t = [], e = {}) {\n    super(t, Object.assign({\n      conditionsMatcher: st,\n      fieldMatcher: at\n    }, e));\n  }\n}\nfunction createMongoAbility(t = [], e = {}) {\n  return new PureAbility(t, Object.assign({\n    conditionsMatcher: st,\n    fieldMatcher: at\n  }, e));\n}\nfunction isAbilityClass(t) {\n  return \"function\" === typeof t.prototype.possibleRulesFor;\n}\nclass ft {\n  constructor(t) {\n    this.F = t;\n  }\n  because(t) {\n    this.F.reason = t;\n    return this;\n  }\n}\nclass AbilityBuilder {\n  constructor(t) {\n    this.rules = [];\n    this._ = t;\n    this.can = (t, e, i, s) => this.O(t, e, i, s, false);\n    this.cannot = (t, e, i, s) => this.O(t, e, i, s, true);\n    this.build = t => isAbilityClass(this._) ? new this._(this.rules, t) : this._(this.rules, t);\n  }\n  O(t, e, i, s, n) {\n    const r = {\n      action: t\n    };\n    if (n) r.inverted = n;\n    if (e) {\n      r.subject = e;\n      if (Array.isArray(i) || \"string\" === typeof i) r.fields = i;else if (\"undefined\" !== typeof i) r.conditions = i;\n      if (\"undefined\" !== typeof s) r.conditions = s;\n    }\n    this.rules.push(r);\n    return new ft(r);\n  }\n}\nfunction defineAbility(t, e) {\n  const i = new AbilityBuilder(createMongoAbility);\n  const s = t(i.can, i.cannot);\n  if (s && \"function\" === typeof s.then) return s.then(() => i.build(e));\n  return i.build(e);\n}\nconst dt = t => `Cannot execute \"${t.action}\" on \"${t.subjectType}\"`;\nconst yt = function t(e) {\n  this.message = e;\n};\nyt.prototype = Object.create(Error.prototype);\nclass ForbiddenError extends yt {\n  static setDefaultMessage(t) {\n    this.C = \"string\" === typeof t ? () => t : t;\n  }\n  static from(t) {\n    return new this(t);\n  }\n  constructor(t) {\n    super(\"\");\n    this.ability = t;\n    if (\"function\" === typeof Error.captureStackTrace) {\n      this.name = \"ForbiddenError\";\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n  setMessage(t) {\n    this.message = t;\n    return this;\n  }\n  throwUnlessCan(t, e, i) {\n    const s = this.unlessCan(t, e, i);\n    if (s) throw s;\n  }\n  unlessCan(t, e, i) {\n    const s = this.ability.relevantRuleFor(t, e, i);\n    if (s && !s.inverted) return;\n    this.action = t;\n    this.subject = e;\n    this.subjectType = B(this.ability.detectSubjectType(e));\n    this.field = i;\n    const n = s ? s.reason : \"\";\n    this.message = this.message || n || this.constructor.C(this);\n    return this;\n  }\n}\nForbiddenError.C = dt;\nvar bt = Object.freeze({\n  __proto__: null\n});\nexport { Ability, AbilityBuilder, ForbiddenError, PureAbility, it as buildMongoQueryMatcher, I as createAliasResolver, createMongoAbility, defineAbility, q as detectSubjectType, at as fieldPatternMatcher, dt as getDefaultErrorMessage, bt as hkt, st as mongoQueryMatcher, P as subject, O as wrapArray };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["import{createFactory as t,$eq as e,$ne as i,$lt as s,$lte as n,$gt as r,$gte as o,$in as c,$nin as u,$all as h,$size as l,$regex as a,$options as f,$elemMatch as d,$exists as y,eq as b,ne as p,lt as w,lte as g,gt as $,gte as A,within as j,nin as M,all as m,size as E,regex as v,elemMatch as x,exists as F,and as _}from\"@ucast/mongo2js\";function O(t){return Array.isArray(t)?t:[t]}const C=Object.hasOwn||Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);const R=\"__caslSubjectType__\";function P(t,e){if(e)if(!C(e,R))Object.defineProperty(e,R,{value:t});else if(t!==e[R])throw new Error(`Trying to cast object to subject type ${t} but previously it was casted to ${e[R]}`);return e}const S=t=>{const e=typeof t;return\"string\"===e||\"function\"===e};const T=t=>t.modelName||t.name;const B=t=>\"string\"===typeof t?t:T(t);function q(t){if(C(t,R))return t[R];return T(t.constructor)}function z(t,e,i){let s=O(e);let n=0;while(n<s.length){const e=s[n++];if(C(t,e))s=i(s,t[e])}return s}function D(t,e){if(\"string\"===typeof e&&-1!==t.indexOf(e))return e;for(let i=0;i<e.length;i++)if(-1!==t.indexOf(e[i]))return e[i];return null}const Y=(t,e)=>t.concat(e);function k(t,e){if(e in t)throw new Error(`Cannot use \"${e}\" as an alias because it's reserved action.`);const i=Object.keys(t);const s=(t,i)=>{const s=D(t,i);if(s)throw new Error(`Detected cycle ${s} -> ${t.join(\", \")}`);const n=\"string\"===typeof i&&i===e||-1!==t.indexOf(e)||Array.isArray(i)&&-1!==i.indexOf(e);if(n)throw new Error(`Cannot make an alias to \"${e}\" because this is reserved action`);return t.concat(i)};for(let e=0;e<i.length;e++)z(t,i[e],s)}function I(t,e){if(!e||false!==e.skipValidate)k(t,e&&e.anyAction||\"manage\");return e=>z(t,e,Y)}function L(t,e,i){for(let s=i;s<e.length;s++)t.push(e[s])}function U(t,e){if(!t||!t.length)return e||[];if(!e||!e.length)return t||[];let i=0;let s=0;const n=[];while(i<t.length&&s<e.length)if(t[i].priority<e[s].priority){n.push(t[i]);i++}else{n.push(e[s]);s++}L(n,t,i);L(n,e,s);return n}function G(t,e,i){let s=t.get(e);if(!s){s=i();t.set(e,s)}return s}const H=t=>t;function J(t,e){if(Array.isArray(t.fields)&&!t.fields.length)throw new Error(\"`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa\");if(t.fields&&!e.fieldMatcher)throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');if(t.conditions&&!e.conditionsMatcher)throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions')}class K{constructor(t,e,i=0){J(t,e);this.action=e.resolveAction(t.action);this.subject=t.subject;this.inverted=!!t.inverted;this.conditions=t.conditions;this.reason=t.reason;this.origin=t;this.fields=t.fields?O(t.fields):void 0;this.priority=i;this.t=e}i(){if(this.conditions&&!this.o)this.o=this.t.conditionsMatcher(this.conditions);return this.o}get ast(){const t=this.i();return t?t.ast:void 0}matchesConditions(t){if(!this.conditions)return true;if(!t||S(t))return!this.inverted;const e=this.i();return e(t)}matchesField(t){if(!this.fields)return true;if(!t)return!this.inverted;if(this.fields&&!this.u)this.u=this.t.fieldMatcher(this.fields);return this.u(t)}}function N(t,e){const i={value:t,prev:e,next:null};if(e)e.next=i;return i}function Q(t){if(t.next)t.next.prev=t.prev;if(t.prev)t.prev.next=t.next;t.next=t.prev=null}const V=t=>({value:t.value,prev:t.prev,next:t.next});const W=()=>({rules:[],merged:false});const X=()=>new Map;class Z{constructor(t=[],e={}){this.h=false;this.l={conditionsMatcher:e.conditionsMatcher,fieldMatcher:e.fieldMatcher,resolveAction:e.resolveAction||H};this.p=e.anyAction||\"manage\";this.g=e.anySubjectType||\"all\";this.$=e.detectSubjectType||q;this.A=t;this.j=this.M(t)}get rules(){return this.A}detectSubjectType(t){if(S(t))return t;if(!t)return this.g;return this.$(t)}update(t){const e={rules:t,ability:this,target:this};this.m(\"update\",e);this.A=t;this.j=this.M(t);this.m(\"updated\",e);return this}M(t){const e=new Map;for(let i=t.length-1;i>=0;i--){const s=t.length-i-1;const n=new K(t[i],this.l,s);const r=O(n.action);const o=O(n.subject||this.g);if(!this.h&&n.fields)this.h=true;for(let t=0;t<o.length;t++){const i=G(e,o[t],X);for(let t=0;t<r.length;t++)G(i,r[t],W).rules.push(n)}}return e}possibleRulesFor(t,e=this.g){if(!S(e))throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');const i=G(this.j,e,X);const s=G(i,t,W);if(s.merged)return s.rules;const n=t!==this.p&&i.has(this.p)?i.get(this.p).rules:void 0;let r=U(s.rules,n);if(e!==this.g)r=U(r,this.possibleRulesFor(t,this.g));s.rules=r;s.merged=true;return r}rulesFor(t,e,i){const s=this.possibleRulesFor(t,e);if(i&&\"string\"!==typeof i)throw new Error(\"The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details\");if(!this.h)return s;return s.filter((t=>t.matchesField(i)))}actionsFor(t){if(!S(t))throw new Error('\"actionsFor\" accepts only subject types (i.e., string or class) as a parameter');const e=new Set;const i=this.j.get(t);if(i)Array.from(i.keys()).forEach((t=>e.add(t)));const s=t!==this.g?this.j.get(this.g):void 0;if(s)Array.from(s.keys()).forEach((t=>e.add(t)));return Array.from(e)}on(t,e){this.v=this.v||new Map;const i=this.v;const s=i.get(t)||null;const n=N(e,s);i.set(t,n);return()=>{const e=i.get(t);if(!n.next&&!n.prev&&e===n)i.delete(t);else if(n===e)i.set(t,n.prev);Q(n)}}m(t,e){if(!this.v)return;let i=this.v.get(t)||null;while(null!==i){const t=i.prev?V(i.prev):null;i.value(e);i=t}}}class PureAbility extends Z{can(t,e,i){const s=this.relevantRuleFor(t,e,i);return!!s&&!s.inverted}relevantRuleFor(t,e,i){const s=this.detectSubjectType(e);const n=this.rulesFor(t,s,i);for(let t=0,i=n.length;t<i;t++)if(n[t].matchesConditions(e))return n[t];return null}cannot(t,e,i){return!this.can(t,e,i)}}const tt={$eq:e,$ne:i,$lt:s,$lte:n,$gt:r,$gte:o,$in:c,$nin:u,$all:h,$size:l,$regex:a,$options:f,$elemMatch:d,$exists:y};const et={eq:b,ne:p,lt:w,lte:g,gt:$,gte:A,in:j,nin:M,all:m,size:E,regex:v,elemMatch:x,exists:F,and:_};const it=(e,i,s)=>t(Object.assign({},tt,e),Object.assign({},et,i),s);const st=t(tt,et);const nt=/[-/\\\\^$+?.()|[\\]{}]/g;const rt=/\\.?\\*+\\.?/g;const ot=/\\*+/;const ct=/\\./g;function ut(t,e,i){const s=\"*\"===i[0]||\".\"===t[0]&&\".\"===t[t.length-1]?\"+\":\"*\";const n=-1===t.indexOf(\"**\")?\"[^.]\":\".\";const r=t.replace(ct,\"\\\\$&\").replace(ot,n+s);return e+t.length===i.length?`(?:${r})?`:r}function ht(t,e,i){if(\".\"===t&&(\"*\"===i[e-1]||\"*\"===i[e+1]))return t;return`\\\\${t}`}function lt(t){const e=t.map((t=>t.replace(nt,ht).replace(rt,ut)));const i=e.length>1?`(?:${e.join(\"|\")})`:e[0];return new RegExp(`^${i}$`)}const at=t=>{let e;return i=>{if(\"undefined\"===typeof e)e=t.every((t=>-1===t.indexOf(\"*\")))?null:lt(t);return null===e?-1!==t.indexOf(i):e.test(i)}};class Ability extends PureAbility{constructor(t=[],e={}){super(t,Object.assign({conditionsMatcher:st,fieldMatcher:at},e))}}function createMongoAbility(t=[],e={}){return new PureAbility(t,Object.assign({conditionsMatcher:st,fieldMatcher:at},e))}function isAbilityClass(t){return\"function\"===typeof t.prototype.possibleRulesFor}class ft{constructor(t){this.F=t}because(t){this.F.reason=t;return this}}class AbilityBuilder{constructor(t){this.rules=[];this._=t;this.can=(t,e,i,s)=>this.O(t,e,i,s,false);this.cannot=(t,e,i,s)=>this.O(t,e,i,s,true);this.build=t=>isAbilityClass(this._)?new this._(this.rules,t):this._(this.rules,t)}O(t,e,i,s,n){const r={action:t};if(n)r.inverted=n;if(e){r.subject=e;if(Array.isArray(i)||\"string\"===typeof i)r.fields=i;else if(\"undefined\"!==typeof i)r.conditions=i;if(\"undefined\"!==typeof s)r.conditions=s}this.rules.push(r);return new ft(r)}}function defineAbility(t,e){const i=new AbilityBuilder(createMongoAbility);const s=t(i.can,i.cannot);if(s&&\"function\"===typeof s.then)return s.then((()=>i.build(e)));return i.build(e)}const dt=t=>`Cannot execute \"${t.action}\" on \"${t.subjectType}\"`;const yt=function t(e){this.message=e};yt.prototype=Object.create(Error.prototype);class ForbiddenError extends yt{static setDefaultMessage(t){this.C=\"string\"===typeof t?()=>t:t}static from(t){return new this(t)}constructor(t){super(\"\");this.ability=t;if(\"function\"===typeof Error.captureStackTrace){this.name=\"ForbiddenError\";Error.captureStackTrace(this,this.constructor)}}setMessage(t){this.message=t;return this}throwUnlessCan(t,e,i){const s=this.unlessCan(t,e,i);if(s)throw s}unlessCan(t,e,i){const s=this.ability.relevantRuleFor(t,e,i);if(s&&!s.inverted)return;this.action=t;this.subject=e;this.subjectType=B(this.ability.detectSubjectType(e));this.field=i;const n=s?s.reason:\"\";this.message=this.message||n||this.constructor.C(this);return this}}ForbiddenError.C=dt;var bt=Object.freeze({__proto__:null});export{Ability,AbilityBuilder,ForbiddenError,PureAbility,it as buildMongoQueryMatcher,I as createAliasResolver,createMongoAbility,defineAbility,q as detectSubjectType,at as fieldPatternMatcher,dt as getDefaultErrorMessage,bt as hkt,st as mongoQueryMatcher,P as subject,O as wrapArray};\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}