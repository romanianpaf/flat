{"ast":null,"code":"import _assertThisInitialized from \"/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { createFactory as t, $eq as e, $ne as i, $lt as s, $lte as n, $gt as r, $gte as o, $in as c, $nin as u, $all as h, $size as l, $regex as a, $options as f, $elemMatch as d, $exists as y, eq as b, ne as p, lt as w, lte as g, gt as $, gte as A, within as j, nin as M, all as m, size as E, regex as v, elemMatch as x, exists as F, and as _ } from \"@ucast/mongo2js\";\nfunction O(t) {\n  return Array.isArray(t) ? t : [t];\n}\nvar C = Object.hasOwn || Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\nvar R = \"__caslSubjectType__\";\nfunction P(t, e) {\n  if (e) if (!C(e, R)) Object.defineProperty(e, R, {\n    value: t\n  });else if (t !== e[R]) throw new Error(\"Trying to cast object to subject type \".concat(t, \" but previously it was casted to \").concat(e[R]));\n  return e;\n}\nvar S = function S(t) {\n  var e = typeof t;\n  return \"string\" === e || \"function\" === e;\n};\nvar T = function T(t) {\n  return t.modelName || t.name;\n};\nvar B = function B(t) {\n  return \"string\" === typeof t ? t : T(t);\n};\nfunction q(t) {\n  if (C(t, R)) return t[R];\n  return T(t.constructor);\n}\nfunction z(t, e, i) {\n  var s = O(e);\n  var n = 0;\n  while (n < s.length) {\n    var _e = s[n++];\n    if (C(t, _e)) s = i(s, t[_e]);\n  }\n  return s;\n}\nfunction D(t, e) {\n  if (\"string\" === typeof e && -1 !== t.indexOf(e)) return e;\n  for (var _i = 0; _i < e.length; _i++) if (-1 !== t.indexOf(e[_i])) return e[_i];\n  return null;\n}\nvar Y = function Y(t, e) {\n  return t.concat(e);\n};\nfunction k(t, e) {\n  if (e in t) throw new Error(\"Cannot use \\\"\".concat(e, \"\\\" as an alias because it's reserved action.\"));\n  var i = Object.keys(t);\n  var s = function s(t, i) {\n    var s = D(t, i);\n    if (s) throw new Error(\"Detected cycle \".concat(s, \" -> \").concat(t.join(\", \")));\n    var n = \"string\" === typeof i && i === e || -1 !== t.indexOf(e) || Array.isArray(i) && -1 !== i.indexOf(e);\n    if (n) throw new Error(\"Cannot make an alias to \\\"\".concat(e, \"\\\" because this is reserved action\"));\n    return t.concat(i);\n  };\n  for (var _e2 = 0; _e2 < i.length; _e2++) z(t, i[_e2], s);\n}\nfunction I(t, e) {\n  if (!e || false !== e.skipValidate) k(t, e && e.anyAction || \"manage\");\n  return function (e) {\n    return z(t, e, Y);\n  };\n}\nfunction L(t, e, i) {\n  for (var _s = i; _s < e.length; _s++) t.push(e[_s]);\n}\nfunction U(t, e) {\n  if (!t || !t.length) return e || [];\n  if (!e || !e.length) return t || [];\n  var i = 0;\n  var s = 0;\n  var n = [];\n  while (i < t.length && s < e.length) if (t[i].priority < e[s].priority) {\n    n.push(t[i]);\n    i++;\n  } else {\n    n.push(e[s]);\n    s++;\n  }\n  L(n, t, i);\n  L(n, e, s);\n  return n;\n}\nfunction G(t, e, i) {\n  var s = t.get(e);\n  if (!s) {\n    s = i();\n    t.set(e, s);\n  }\n  return s;\n}\nvar H = function H(t) {\n  return t;\n};\nfunction J(t, e) {\n  if (Array.isArray(t.fields) && !t.fields.length) throw new Error(\"`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa\");\n  if (t.fields && !e.fieldMatcher) throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');\n  if (t.conditions && !e.conditionsMatcher) throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions');\n}\nvar K = /*#__PURE__*/function () {\n  function K(t, e) {\n    var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, K);\n    J(t, e);\n    this.action = e.resolveAction(t.action);\n    this.subject = t.subject;\n    this.inverted = !!t.inverted;\n    this.conditions = t.conditions;\n    this.reason = t.reason;\n    this.origin = t;\n    this.fields = t.fields ? O(t.fields) : void 0;\n    this.priority = i;\n    this.t = e;\n  }\n  _createClass(K, [{\n    key: \"i\",\n    value: function i() {\n      if (this.conditions && !this.o) this.o = this.t.conditionsMatcher(this.conditions);\n      return this.o;\n    }\n  }, {\n    key: \"ast\",\n    get: function get() {\n      var t = this.i();\n      return t ? t.ast : void 0;\n    }\n  }, {\n    key: \"matchesConditions\",\n    value: function matchesConditions(t) {\n      if (!this.conditions) return true;\n      if (!t || S(t)) return !this.inverted;\n      var e = this.i();\n      return e(t);\n    }\n  }, {\n    key: \"matchesField\",\n    value: function matchesField(t) {\n      if (!this.fields) return true;\n      if (!t) return !this.inverted;\n      if (this.fields && !this.u) this.u = this.t.fieldMatcher(this.fields);\n      return this.u(t);\n    }\n  }]);\n  return K;\n}();\nfunction N(t, e) {\n  var i = {\n    value: t,\n    prev: e,\n    next: null\n  };\n  if (e) e.next = i;\n  return i;\n}\nfunction Q(t) {\n  if (t.next) t.next.prev = t.prev;\n  if (t.prev) t.prev.next = t.next;\n  t.next = t.prev = null;\n}\nvar V = function V(t) {\n  return {\n    value: t.value,\n    prev: t.prev,\n    next: t.next\n  };\n};\nvar W = function W() {\n  return {\n    rules: [],\n    merged: false\n  };\n};\nvar X = function X() {\n  return new Map();\n};\nvar Z = /*#__PURE__*/function () {\n  function Z() {\n    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Z);\n    this.h = false;\n    this.l = {\n      conditionsMatcher: e.conditionsMatcher,\n      fieldMatcher: e.fieldMatcher,\n      resolveAction: e.resolveAction || H\n    };\n    this.p = e.anyAction || \"manage\";\n    this.g = e.anySubjectType || \"all\";\n    this.$ = e.detectSubjectType || q;\n    this.A = t;\n    this.j = this.M(t);\n  }\n  _createClass(Z, [{\n    key: \"rules\",\n    get: function get() {\n      return this.A;\n    }\n  }, {\n    key: \"detectSubjectType\",\n    value: function detectSubjectType(t) {\n      if (S(t)) return t;\n      if (!t) return this.g;\n      return this.$(t);\n    }\n  }, {\n    key: \"update\",\n    value: function update(t) {\n      var e = {\n        rules: t,\n        ability: this,\n        target: this\n      };\n      this.m(\"update\", e);\n      this.A = t;\n      this.j = this.M(t);\n      this.m(\"updated\", e);\n      return this;\n    }\n  }, {\n    key: \"M\",\n    value: function M(t) {\n      var e = new Map();\n      for (var _i2 = t.length - 1; _i2 >= 0; _i2--) {\n        var _s2 = t.length - _i2 - 1;\n        var _n = new K(t[_i2], this.l, _s2);\n        var _r = O(_n.action);\n        var _o = O(_n.subject || this.g);\n        if (!this.h && _n.fields) this.h = true;\n        for (var _t = 0; _t < _o.length; _t++) {\n          var _i3 = G(e, _o[_t], X);\n          for (var _t2 = 0; _t2 < _r.length; _t2++) G(_i3, _r[_t2], W).rules.push(_n);\n        }\n      }\n      return e;\n    }\n  }, {\n    key: \"possibleRulesFor\",\n    value: function possibleRulesFor(t) {\n      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.g;\n      if (!S(e)) throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');\n      var i = G(this.j, e, X);\n      var s = G(i, t, W);\n      if (s.merged) return s.rules;\n      var n = t !== this.p && i.has(this.p) ? i.get(this.p).rules : void 0;\n      var r = U(s.rules, n);\n      if (e !== this.g) r = U(r, this.possibleRulesFor(t, this.g));\n      s.rules = r;\n      s.merged = true;\n      return r;\n    }\n  }, {\n    key: \"rulesFor\",\n    value: function rulesFor(t, e, i) {\n      var s = this.possibleRulesFor(t, e);\n      if (i && \"string\" !== typeof i) throw new Error(\"The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details\");\n      if (!this.h) return s;\n      return s.filter(function (t) {\n        return t.matchesField(i);\n      });\n    }\n  }, {\n    key: \"actionsFor\",\n    value: function actionsFor(t) {\n      if (!S(t)) throw new Error('\"actionsFor\" accepts only subject types (i.e., string or class) as a parameter');\n      var e = new Set();\n      var i = this.j.get(t);\n      if (i) Array.from(i.keys()).forEach(function (t) {\n        return e.add(t);\n      });\n      var s = t !== this.g ? this.j.get(this.g) : void 0;\n      if (s) Array.from(s.keys()).forEach(function (t) {\n        return e.add(t);\n      });\n      return Array.from(e);\n    }\n  }, {\n    key: \"on\",\n    value: function on(t, e) {\n      this.v = this.v || new Map();\n      var i = this.v;\n      var s = i.get(t) || null;\n      var n = N(e, s);\n      i.set(t, n);\n      return function () {\n        var e = i.get(t);\n        if (!n.next && !n.prev && e === n) i.delete(t);else if (n === e) i.set(t, n.prev);\n        Q(n);\n      };\n    }\n  }, {\n    key: \"m\",\n    value: function m(t, e) {\n      if (!this.v) return;\n      var i = this.v.get(t) || null;\n      while (null !== i) {\n        var _t3 = i.prev ? V(i.prev) : null;\n        i.value(e);\n        i = _t3;\n      }\n    }\n  }]);\n  return Z;\n}();\nvar PureAbility = /*#__PURE__*/function (_Z) {\n  _inherits(PureAbility, _Z);\n  var _super = _createSuper(PureAbility);\n  function PureAbility() {\n    _classCallCheck(this, PureAbility);\n    return _super.apply(this, arguments);\n  }\n  _createClass(PureAbility, [{\n    key: \"can\",\n    value: function can(t, e, i) {\n      var s = this.relevantRuleFor(t, e, i);\n      return !!s && !s.inverted;\n    }\n  }, {\n    key: \"relevantRuleFor\",\n    value: function relevantRuleFor(t, e, i) {\n      var s = this.detectSubjectType(e);\n      var n = this.rulesFor(t, s, i);\n      for (var _t4 = 0, _i4 = n.length; _t4 < _i4; _t4++) if (n[_t4].matchesConditions(e)) return n[_t4];\n      return null;\n    }\n  }, {\n    key: \"cannot\",\n    value: function cannot(t, e, i) {\n      return !this.can(t, e, i);\n    }\n  }]);\n  return PureAbility;\n}(Z);\nvar tt = {\n  $eq: e,\n  $ne: i,\n  $lt: s,\n  $lte: n,\n  $gt: r,\n  $gte: o,\n  $in: c,\n  $nin: u,\n  $all: h,\n  $size: l,\n  $regex: a,\n  $options: f,\n  $elemMatch: d,\n  $exists: y\n};\nvar et = {\n  eq: b,\n  ne: p,\n  lt: w,\n  lte: g,\n  gt: $,\n  gte: A,\n  in: j,\n  nin: M,\n  all: m,\n  size: E,\n  regex: v,\n  elemMatch: x,\n  exists: F,\n  and: _\n};\nvar it = function it(e, i, s) {\n  return t(Object.assign({}, tt, e), Object.assign({}, et, i), s);\n};\nvar st = t(tt, et);\nvar nt = /[-/\\\\^$+?.()|[\\]{}]/g;\nvar rt = /\\.?\\*+\\.?/g;\nvar ot = /\\*+/;\nvar ct = /\\./g;\nfunction ut(t, e, i) {\n  var s = \"*\" === i[0] || \".\" === t[0] && \".\" === t[t.length - 1] ? \"+\" : \"*\";\n  var n = -1 === t.indexOf(\"**\") ? \"[^.]\" : \".\";\n  var r = t.replace(ct, \"\\\\$&\").replace(ot, n + s);\n  return e + t.length === i.length ? \"(?:\".concat(r, \")?\") : r;\n}\nfunction ht(t, e, i) {\n  if (\".\" === t && (\"*\" === i[e - 1] || \"*\" === i[e + 1])) return t;\n  return \"\\\\\".concat(t);\n}\nfunction lt(t) {\n  var e = t.map(function (t) {\n    return t.replace(nt, ht).replace(rt, ut);\n  });\n  var i = e.length > 1 ? \"(?:\".concat(e.join(\"|\"), \")\") : e[0];\n  return new RegExp(\"^\".concat(i, \"$\"));\n}\nvar at = function at(t) {\n  var e;\n  return function (i) {\n    if (\"undefined\" === typeof e) e = t.every(function (t) {\n      return -1 === t.indexOf(\"*\");\n    }) ? null : lt(t);\n    return null === e ? -1 !== t.indexOf(i) : e.test(i);\n  };\n};\nvar Ability = /*#__PURE__*/function (_PureAbility) {\n  _inherits(Ability, _PureAbility);\n  var _super2 = _createSuper(Ability);\n  function Ability() {\n    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Ability);\n    return _super2.call(this, t, Object.assign({\n      conditionsMatcher: st,\n      fieldMatcher: at\n    }, e));\n  }\n  return _createClass(Ability);\n}(PureAbility);\nfunction createMongoAbility() {\n  var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new PureAbility(t, Object.assign({\n    conditionsMatcher: st,\n    fieldMatcher: at\n  }, e));\n}\nfunction isAbilityClass(t) {\n  return \"function\" === typeof t.prototype.possibleRulesFor;\n}\nvar ft = /*#__PURE__*/function () {\n  function ft(t) {\n    _classCallCheck(this, ft);\n    this.F = t;\n  }\n  _createClass(ft, [{\n    key: \"because\",\n    value: function because(t) {\n      this.F.reason = t;\n      return this;\n    }\n  }]);\n  return ft;\n}();\nvar AbilityBuilder = /*#__PURE__*/function () {\n  function AbilityBuilder(t) {\n    var _this = this;\n    _classCallCheck(this, AbilityBuilder);\n    this.rules = [];\n    this._ = t;\n    this.can = function (t, e, i, s) {\n      return _this.O(t, e, i, s, false);\n    };\n    this.cannot = function (t, e, i, s) {\n      return _this.O(t, e, i, s, true);\n    };\n    this.build = function (t) {\n      return isAbilityClass(_this._) ? new _this._(_this.rules, t) : _this._(_this.rules, t);\n    };\n  }\n  _createClass(AbilityBuilder, [{\n    key: \"O\",\n    value: function O(t, e, i, s, n) {\n      var r = {\n        action: t\n      };\n      if (n) r.inverted = n;\n      if (e) {\n        r.subject = e;\n        if (Array.isArray(i) || \"string\" === typeof i) r.fields = i;else if (\"undefined\" !== typeof i) r.conditions = i;\n        if (\"undefined\" !== typeof s) r.conditions = s;\n      }\n      this.rules.push(r);\n      return new ft(r);\n    }\n  }]);\n  return AbilityBuilder;\n}();\nfunction defineAbility(t, e) {\n  var i = new AbilityBuilder(createMongoAbility);\n  var s = t(i.can, i.cannot);\n  if (s && \"function\" === typeof s.then) return s.then(function () {\n    return i.build(e);\n  });\n  return i.build(e);\n}\nvar dt = function dt(t) {\n  return \"Cannot execute \\\"\".concat(t.action, \"\\\" on \\\"\").concat(t.subjectType, \"\\\"\");\n};\nvar yt = function t(e) {\n  this.message = e;\n};\nyt.prototype = Object.create(Error.prototype);\nvar ForbiddenError = /*#__PURE__*/function (_yt) {\n  _inherits(ForbiddenError, _yt);\n  var _super3 = _createSuper(ForbiddenError);\n  function ForbiddenError(t) {\n    var _this2;\n    _classCallCheck(this, ForbiddenError);\n    _this2 = _super3.call(this, \"\");\n    _this2.ability = t;\n    if (\"function\" === typeof Error.captureStackTrace) {\n      _this2.name = \"ForbiddenError\";\n      Error.captureStackTrace(_assertThisInitialized(_this2), _this2.constructor);\n    }\n    return _this2;\n  }\n  _createClass(ForbiddenError, [{\n    key: \"setMessage\",\n    value: function setMessage(t) {\n      this.message = t;\n      return this;\n    }\n  }, {\n    key: \"throwUnlessCan\",\n    value: function throwUnlessCan(t, e, i) {\n      var s = this.unlessCan(t, e, i);\n      if (s) throw s;\n    }\n  }, {\n    key: \"unlessCan\",\n    value: function unlessCan(t, e, i) {\n      var s = this.ability.relevantRuleFor(t, e, i);\n      if (s && !s.inverted) return;\n      this.action = t;\n      this.subject = e;\n      this.subjectType = B(this.ability.detectSubjectType(e));\n      this.field = i;\n      var n = s ? s.reason : \"\";\n      this.message = this.message || n || this.constructor.C(this);\n      return this;\n    }\n  }], [{\n    key: \"setDefaultMessage\",\n    value: function setDefaultMessage(t) {\n      this.C = \"string\" === typeof t ? function () {\n        return t;\n      } : t;\n    }\n  }, {\n    key: \"from\",\n    value: function from(t) {\n      return new this(t);\n    }\n  }]);\n  return ForbiddenError;\n}(yt);\nForbiddenError.C = dt;\nvar bt = Object.freeze({\n  __proto__: null\n});\nexport { Ability, AbilityBuilder, ForbiddenError, PureAbility, it as buildMongoQueryMatcher, I as createAliasResolver, createMongoAbility, defineAbility, q as detectSubjectType, at as fieldPatternMatcher, dt as getDefaultErrorMessage, bt as hkt, st as mongoQueryMatcher, P as subject, O as wrapArray };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["import{createFactory as t,$eq as e,$ne as i,$lt as s,$lte as n,$gt as r,$gte as o,$in as c,$nin as u,$all as h,$size as l,$regex as a,$options as f,$elemMatch as d,$exists as y,eq as b,ne as p,lt as w,lte as g,gt as $,gte as A,within as j,nin as M,all as m,size as E,regex as v,elemMatch as x,exists as F,and as _}from\"@ucast/mongo2js\";function O(t){return Array.isArray(t)?t:[t]}const C=Object.hasOwn||Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);const R=\"__caslSubjectType__\";function P(t,e){if(e)if(!C(e,R))Object.defineProperty(e,R,{value:t});else if(t!==e[R])throw new Error(`Trying to cast object to subject type ${t} but previously it was casted to ${e[R]}`);return e}const S=t=>{const e=typeof t;return\"string\"===e||\"function\"===e};const T=t=>t.modelName||t.name;const B=t=>\"string\"===typeof t?t:T(t);function q(t){if(C(t,R))return t[R];return T(t.constructor)}function z(t,e,i){let s=O(e);let n=0;while(n<s.length){const e=s[n++];if(C(t,e))s=i(s,t[e])}return s}function D(t,e){if(\"string\"===typeof e&&-1!==t.indexOf(e))return e;for(let i=0;i<e.length;i++)if(-1!==t.indexOf(e[i]))return e[i];return null}const Y=(t,e)=>t.concat(e);function k(t,e){if(e in t)throw new Error(`Cannot use \"${e}\" as an alias because it's reserved action.`);const i=Object.keys(t);const s=(t,i)=>{const s=D(t,i);if(s)throw new Error(`Detected cycle ${s} -> ${t.join(\", \")}`);const n=\"string\"===typeof i&&i===e||-1!==t.indexOf(e)||Array.isArray(i)&&-1!==i.indexOf(e);if(n)throw new Error(`Cannot make an alias to \"${e}\" because this is reserved action`);return t.concat(i)};for(let e=0;e<i.length;e++)z(t,i[e],s)}function I(t,e){if(!e||false!==e.skipValidate)k(t,e&&e.anyAction||\"manage\");return e=>z(t,e,Y)}function L(t,e,i){for(let s=i;s<e.length;s++)t.push(e[s])}function U(t,e){if(!t||!t.length)return e||[];if(!e||!e.length)return t||[];let i=0;let s=0;const n=[];while(i<t.length&&s<e.length)if(t[i].priority<e[s].priority){n.push(t[i]);i++}else{n.push(e[s]);s++}L(n,t,i);L(n,e,s);return n}function G(t,e,i){let s=t.get(e);if(!s){s=i();t.set(e,s)}return s}const H=t=>t;function J(t,e){if(Array.isArray(t.fields)&&!t.fields.length)throw new Error(\"`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa\");if(t.fields&&!e.fieldMatcher)throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');if(t.conditions&&!e.conditionsMatcher)throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions')}class K{constructor(t,e,i=0){J(t,e);this.action=e.resolveAction(t.action);this.subject=t.subject;this.inverted=!!t.inverted;this.conditions=t.conditions;this.reason=t.reason;this.origin=t;this.fields=t.fields?O(t.fields):void 0;this.priority=i;this.t=e}i(){if(this.conditions&&!this.o)this.o=this.t.conditionsMatcher(this.conditions);return this.o}get ast(){const t=this.i();return t?t.ast:void 0}matchesConditions(t){if(!this.conditions)return true;if(!t||S(t))return!this.inverted;const e=this.i();return e(t)}matchesField(t){if(!this.fields)return true;if(!t)return!this.inverted;if(this.fields&&!this.u)this.u=this.t.fieldMatcher(this.fields);return this.u(t)}}function N(t,e){const i={value:t,prev:e,next:null};if(e)e.next=i;return i}function Q(t){if(t.next)t.next.prev=t.prev;if(t.prev)t.prev.next=t.next;t.next=t.prev=null}const V=t=>({value:t.value,prev:t.prev,next:t.next});const W=()=>({rules:[],merged:false});const X=()=>new Map;class Z{constructor(t=[],e={}){this.h=false;this.l={conditionsMatcher:e.conditionsMatcher,fieldMatcher:e.fieldMatcher,resolveAction:e.resolveAction||H};this.p=e.anyAction||\"manage\";this.g=e.anySubjectType||\"all\";this.$=e.detectSubjectType||q;this.A=t;this.j=this.M(t)}get rules(){return this.A}detectSubjectType(t){if(S(t))return t;if(!t)return this.g;return this.$(t)}update(t){const e={rules:t,ability:this,target:this};this.m(\"update\",e);this.A=t;this.j=this.M(t);this.m(\"updated\",e);return this}M(t){const e=new Map;for(let i=t.length-1;i>=0;i--){const s=t.length-i-1;const n=new K(t[i],this.l,s);const r=O(n.action);const o=O(n.subject||this.g);if(!this.h&&n.fields)this.h=true;for(let t=0;t<o.length;t++){const i=G(e,o[t],X);for(let t=0;t<r.length;t++)G(i,r[t],W).rules.push(n)}}return e}possibleRulesFor(t,e=this.g){if(!S(e))throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');const i=G(this.j,e,X);const s=G(i,t,W);if(s.merged)return s.rules;const n=t!==this.p&&i.has(this.p)?i.get(this.p).rules:void 0;let r=U(s.rules,n);if(e!==this.g)r=U(r,this.possibleRulesFor(t,this.g));s.rules=r;s.merged=true;return r}rulesFor(t,e,i){const s=this.possibleRulesFor(t,e);if(i&&\"string\"!==typeof i)throw new Error(\"The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details\");if(!this.h)return s;return s.filter((t=>t.matchesField(i)))}actionsFor(t){if(!S(t))throw new Error('\"actionsFor\" accepts only subject types (i.e., string or class) as a parameter');const e=new Set;const i=this.j.get(t);if(i)Array.from(i.keys()).forEach((t=>e.add(t)));const s=t!==this.g?this.j.get(this.g):void 0;if(s)Array.from(s.keys()).forEach((t=>e.add(t)));return Array.from(e)}on(t,e){this.v=this.v||new Map;const i=this.v;const s=i.get(t)||null;const n=N(e,s);i.set(t,n);return()=>{const e=i.get(t);if(!n.next&&!n.prev&&e===n)i.delete(t);else if(n===e)i.set(t,n.prev);Q(n)}}m(t,e){if(!this.v)return;let i=this.v.get(t)||null;while(null!==i){const t=i.prev?V(i.prev):null;i.value(e);i=t}}}class PureAbility extends Z{can(t,e,i){const s=this.relevantRuleFor(t,e,i);return!!s&&!s.inverted}relevantRuleFor(t,e,i){const s=this.detectSubjectType(e);const n=this.rulesFor(t,s,i);for(let t=0,i=n.length;t<i;t++)if(n[t].matchesConditions(e))return n[t];return null}cannot(t,e,i){return!this.can(t,e,i)}}const tt={$eq:e,$ne:i,$lt:s,$lte:n,$gt:r,$gte:o,$in:c,$nin:u,$all:h,$size:l,$regex:a,$options:f,$elemMatch:d,$exists:y};const et={eq:b,ne:p,lt:w,lte:g,gt:$,gte:A,in:j,nin:M,all:m,size:E,regex:v,elemMatch:x,exists:F,and:_};const it=(e,i,s)=>t(Object.assign({},tt,e),Object.assign({},et,i),s);const st=t(tt,et);const nt=/[-/\\\\^$+?.()|[\\]{}]/g;const rt=/\\.?\\*+\\.?/g;const ot=/\\*+/;const ct=/\\./g;function ut(t,e,i){const s=\"*\"===i[0]||\".\"===t[0]&&\".\"===t[t.length-1]?\"+\":\"*\";const n=-1===t.indexOf(\"**\")?\"[^.]\":\".\";const r=t.replace(ct,\"\\\\$&\").replace(ot,n+s);return e+t.length===i.length?`(?:${r})?`:r}function ht(t,e,i){if(\".\"===t&&(\"*\"===i[e-1]||\"*\"===i[e+1]))return t;return`\\\\${t}`}function lt(t){const e=t.map((t=>t.replace(nt,ht).replace(rt,ut)));const i=e.length>1?`(?:${e.join(\"|\")})`:e[0];return new RegExp(`^${i}$`)}const at=t=>{let e;return i=>{if(\"undefined\"===typeof e)e=t.every((t=>-1===t.indexOf(\"*\")))?null:lt(t);return null===e?-1!==t.indexOf(i):e.test(i)}};class Ability extends PureAbility{constructor(t=[],e={}){super(t,Object.assign({conditionsMatcher:st,fieldMatcher:at},e))}}function createMongoAbility(t=[],e={}){return new PureAbility(t,Object.assign({conditionsMatcher:st,fieldMatcher:at},e))}function isAbilityClass(t){return\"function\"===typeof t.prototype.possibleRulesFor}class ft{constructor(t){this.F=t}because(t){this.F.reason=t;return this}}class AbilityBuilder{constructor(t){this.rules=[];this._=t;this.can=(t,e,i,s)=>this.O(t,e,i,s,false);this.cannot=(t,e,i,s)=>this.O(t,e,i,s,true);this.build=t=>isAbilityClass(this._)?new this._(this.rules,t):this._(this.rules,t)}O(t,e,i,s,n){const r={action:t};if(n)r.inverted=n;if(e){r.subject=e;if(Array.isArray(i)||\"string\"===typeof i)r.fields=i;else if(\"undefined\"!==typeof i)r.conditions=i;if(\"undefined\"!==typeof s)r.conditions=s}this.rules.push(r);return new ft(r)}}function defineAbility(t,e){const i=new AbilityBuilder(createMongoAbility);const s=t(i.can,i.cannot);if(s&&\"function\"===typeof s.then)return s.then((()=>i.build(e)));return i.build(e)}const dt=t=>`Cannot execute \"${t.action}\" on \"${t.subjectType}\"`;const yt=function t(e){this.message=e};yt.prototype=Object.create(Error.prototype);class ForbiddenError extends yt{static setDefaultMessage(t){this.C=\"string\"===typeof t?()=>t:t}static from(t){return new this(t)}constructor(t){super(\"\");this.ability=t;if(\"function\"===typeof Error.captureStackTrace){this.name=\"ForbiddenError\";Error.captureStackTrace(this,this.constructor)}}setMessage(t){this.message=t;return this}throwUnlessCan(t,e,i){const s=this.unlessCan(t,e,i);if(s)throw s}unlessCan(t,e,i){const s=this.ability.relevantRuleFor(t,e,i);if(s&&!s.inverted)return;this.action=t;this.subject=e;this.subjectType=B(this.ability.detectSubjectType(e));this.field=i;const n=s?s.reason:\"\";this.message=this.message||n||this.constructor.C(this);return this}}ForbiddenError.C=dt;var bt=Object.freeze({__proto__:null});export{Ability,AbilityBuilder,ForbiddenError,PureAbility,it as buildMongoQueryMatcher,I as createAliasResolver,createMongoAbility,defineAbility,q as detectSubjectType,at as fieldPatternMatcher,dt as getDefaultErrorMessage,bt as hkt,st as mongoQueryMatcher,P as subject,O as wrapArray};\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}