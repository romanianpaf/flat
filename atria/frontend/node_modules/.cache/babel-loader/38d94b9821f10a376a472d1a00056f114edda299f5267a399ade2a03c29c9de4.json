{"ast":null,"code":"import _toConsumableArray from \"/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _inherits from \"/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar t = /*#__PURE__*/function () {\n  function t(_t, e) {\n    _classCallCheck(this, t);\n    this.operator = _t, this.value = e, Object.defineProperty(this, \"t\", {\n      writable: !0\n    });\n  }\n  _createClass(t, [{\n    key: \"notes\",\n    get: function get() {\n      return this.t;\n    }\n  }, {\n    key: \"addNote\",\n    value: function addNote(_t2) {\n      this.t = this.t || [], this.t.push(_t2);\n    }\n  }]);\n  return t;\n}();\nvar e = /*#__PURE__*/function (_t3) {\n  _inherits(e, _t3);\n  var _super = _createSuper(e);\n  function e() {\n    _classCallCheck(this, e);\n    return _super.apply(this, arguments);\n  }\n  return _createClass(e);\n}(t);\nvar r = /*#__PURE__*/function (_e) {\n  _inherits(r, _e);\n  var _super2 = _createSuper(r);\n  function r(t, e) {\n    _classCallCheck(this, r);\n    if (!Array.isArray(e)) throw new Error(\"\\\"\".concat(t, \"\\\" operator expects to receive an array of conditions\"));\n    return _super2.call(this, t, e);\n  }\n  return _createClass(r);\n}(e);\nvar n = \"__itself__\";\nvar o = /*#__PURE__*/function (_t4) {\n  _inherits(o, _t4);\n  var _super3 = _createSuper(o);\n  function o(t, e, r) {\n    var _this;\n    _classCallCheck(this, o);\n    _this = _super3.call(this, t, r), _this.field = e;\n    return _this;\n  }\n  return _createClass(o);\n}(t);\nvar s = new e(\"__null__\", null),\n  i = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\nfunction c(t, e) {\n  return e instanceof r && e.operator === t;\n}\nfunction u(t, e) {\n  return 1 === e.length ? e[0] : new r(t, function t(e, r, n) {\n    var o = n || [];\n    for (var _n = 0, _s = r.length; _n < _s; _n++) {\n      var _s2 = r[_n];\n      c(e, _s2) ? t(e, _s2.value, o) : o.push(_s2);\n    }\n    return o;\n  }(t, e));\n}\nvar a = function a(t) {\n    return t;\n  },\n  h = function h() {\n    return Object.create(null);\n  },\n  f = Object.defineProperty(h(), \"__@type@__\", {\n    value: \"ignore value\"\n  });\nfunction l(t, e) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n  if (!t || t && t.constructor !== Object) return !1;\n  for (var _n2 in t) {\n    if (i(t, _n2) && i(e, _n2) && (!r || t[_n2] !== f)) return !0;\n  }\n  return !1;\n}\nfunction d(t) {\n  var e = [];\n  for (var _r in t) i(t, _r) && t[_r] !== f && e.push(_r);\n  return e;\n}\nfunction p(t, e) {\n  e !== s && t.push(e);\n}\nvar w = function w(t) {\n    return u(\"and\", t);\n  },\n  b = function b(t) {\n    return u(\"or\", t);\n  },\n  O = {\n    compound: function compound(t, e, n) {\n      var o = (Array.isArray(e) ? e : [e]).map(function (t) {\n        return n.parse(t);\n      });\n      return new r(t.name, o);\n    },\n    field: function field(t, e, r) {\n      return new o(t.name, r.field, e);\n    },\n    document: function document(t, r) {\n      return new e(t.name, r);\n    }\n  };\nvar j = /*#__PURE__*/function () {\n  function j(t) {\n    var _this2 = this;\n    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : h();\n    _classCallCheck(this, j);\n    this.o = void 0, this.s = void 0, this.i = void 0, this.u = void 0, this.h = void 0, this.parse = this.parse.bind(this), this.u = {\n      operatorToConditionName: e.operatorToConditionName || a,\n      defaultOperatorName: e.defaultOperatorName || \"eq\",\n      mergeFinalConditions: e.mergeFinalConditions || w\n    }, this.o = Object.keys(t).reduce(function (e, r) {\n      return e[r] = Object.assign({\n        name: _this2.u.operatorToConditionName(r)\n      }, t[r]), e;\n    }, {}), this.s = Object.assign({}, e.fieldContext, {\n      field: \"\",\n      query: {},\n      parse: this.parse,\n      hasOperators: function hasOperators(t) {\n        return l(t, _this2.o, e.useIgnoreValue);\n      }\n    }), this.i = Object.assign({}, e.documentContext, {\n      parse: this.parse,\n      query: {}\n    }), this.h = e.useIgnoreValue ? d : Object.keys;\n  }\n  _createClass(j, [{\n    key: \"setParse\",\n    value: function setParse(t) {\n      this.parse = t, this.s.parse = t, this.i.parse = t;\n    }\n  }, {\n    key: \"parseField\",\n    value: function parseField(t, e, r, n) {\n      var o = this.o[e];\n      if (!o) throw new Error(\"Unsupported operator \\\"\".concat(e, \"\\\"\"));\n      if (\"field\" !== o.type) throw new Error(\"Unexpected \".concat(o.type, \" operator \\\"\").concat(e, \"\\\" at field level\"));\n      return this.s.field = t, this.s.query = n, this.parseInstruction(o, r, this.s);\n    }\n  }, {\n    key: \"parseInstruction\",\n    value: function parseInstruction(t, e, r) {\n      \"function\" == typeof t.validate && t.validate(t, e);\n      return (t.parse || O[t.type])(t, e, r);\n    }\n  }, {\n    key: \"parseFieldOperators\",\n    value: function parseFieldOperators(t, e) {\n      var r = [],\n        n = this.h(e);\n      for (var _o = 0, _s3 = n.length; _o < _s3; _o++) {\n        var _s4 = n[_o];\n        if (!this.o[_s4]) throw new Error(\"Field query for \\\"\".concat(t, \"\\\" may contain only operators or a plain object as a value\"));\n        p(r, this.parseField(t, _s4, e[_s4], e));\n      }\n      return r;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(t) {\n      var e = [],\n        r = this.h(t);\n      this.i.query = t;\n      for (var _n3 = 0, _o2 = r.length; _n3 < _o2; _n3++) {\n        var _o3 = r[_n3],\n          _s5 = t[_o3],\n          _i = this.o[_o3];\n        if (_i) {\n          if (\"document\" !== _i.type && \"compound\" !== _i.type) throw new Error(\"Cannot use parsing instruction for operator \\\"\".concat(_o3, \"\\\" in \\\"document\\\" context as it is supposed to be used in  \\\"\").concat(_i.type, \"\\\" context\"));\n          p(e, this.parseInstruction(_i, _s5, this.i));\n        } else this.s.hasOperators(_s5) ? e.push.apply(e, _toConsumableArray(this.parseFieldOperators(_o3, _s5))) : p(e, this.parseField(_o3, this.u.defaultOperatorName, _s5, t));\n      }\n      return this.u.mergeFinalConditions(e);\n    }\n  }]);\n  return j;\n}();\nfunction _(t, e) {\n  var r = t[e];\n  if (\"function\" != typeof r) throw new Error(\"Unable to interpret \\\"\".concat(e, \"\\\" condition. Did you forget to register interpreter for it?\"));\n  return r;\n}\nfunction y(t) {\n  return t.operator;\n}\nfunction m(t, e) {\n  var r = e,\n    n = r && r.getInterpreterName || y;\n  var o;\n  switch (r ? r.numberOfArguments : 0) {\n    case 1:\n      o = function o(e) {\n        var o = n(e, r);\n        return _(t, o)(e, s);\n      };\n      break;\n    case 3:\n      o = function o(e, _o4, i) {\n        var c = n(e, r);\n        return _(t, c)(e, _o4, i, s);\n      };\n      break;\n    default:\n      o = function o(e, _o5) {\n        var i = n(e, r);\n        return _(t, i)(e, _o5, s);\n      };\n  }\n  var s = Object.assign({}, r, {\n    interpret: o\n  });\n  return s.interpret;\n}\nfunction v(t, e) {\n  return function (r) {\n    for (var _len = arguments.length, n = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      n[_key - 1] = arguments[_key];\n    }\n    var o = t.apply(void 0, [r].concat(n)),\n      s = e.bind(null, o);\n    return s.ast = o, s;\n  };\n}\nvar x = j.prototype.parseInstruction;\nexport { r as CompoundCondition, t as Condition, e as DocumentCondition, o as FieldCondition, n as ITSELF, s as NULL_CONDITION, j as ObjectQueryParser, w as buildAnd, b as buildOr, m as createInterpreter, v as createTranslatorFactory, O as defaultInstructionParsers, l as hasOperators, a as identity, f as ignoreValue, c as isCompound, h as object, u as optimizedCompoundCondition, x as parseInstruction };","map":{"version":3,"names":["t","e","_classCallCheck","operator","value","Object","defineProperty","writable","_createClass","key","get","addNote","push","_t3","_inherits","_super","_createSuper","apply","arguments","r","_e","_super2","Array","isArray","Error","concat","call","n","o","_t4","_super3","_this","field","s","i","prototype","hasOwnProperty","bind","c","u","length","a","h","create","f","l","undefined","constructor","d","p","w","b","O","compound","map","parse","name","document","j","_this2","operatorToConditionName","defaultOperatorName","mergeFinalConditions","keys","reduce","assign","fieldContext","query","hasOperators","useIgnoreValue","documentContext","setParse","parseField","type","parseInstruction","validate","parseFieldOperators","_toConsumableArray","_","y","m","getInterpreterName","numberOfArguments","interpret","v","_len","_key","ast","x","CompoundCondition","Condition","DocumentCondition","FieldCondition","ITSELF","NULL_CONDITION","ObjectQueryParser","buildAnd","buildOr","createInterpreter","createTranslatorFactory","defaultInstructionParsers","identity","ignoreValue","isCompound","object","optimizedCompoundCondition"],"sources":["/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@ucast/core/src/Condition.ts","/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@ucast/core/src/utils.ts","/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@ucast/core/src/builder.ts","/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@ucast/core/src/parsers/defaultInstructionParsers.ts","/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@ucast/core/src/parsers/ObjectQueryParser.ts","/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@ucast/core/src/interpreter.ts","/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@ucast/core/src/translator.ts","/home/atria/public_html/f1.atria.live/atria/frontend/node_modules/@ucast/core/src/index.ts"],"sourcesContent":["export interface Note<T> {\n  type: string\n  message?: string\n  originalValue?: T\n}\n\nexport abstract class Condition<T = unknown> {\n  private _notes!: Note<T>[];\n\n  constructor(\n    public readonly operator: string,\n    public readonly value: T\n  ) {\n    Object.defineProperty(this, '_notes', {\n      writable: true\n    });\n  }\n\n  get notes(): ReadonlyArray<Note<T>> | undefined {\n    return this._notes;\n  }\n\n  addNote(note: Note<T>) {\n    this._notes = this._notes || [];\n    this._notes.push(note);\n  }\n}\n\nexport class DocumentCondition<T> extends Condition<T> {\n}\n\nexport class CompoundCondition<T extends Condition = Condition> extends DocumentCondition<T[]> {\n  constructor(operator: string, conditions: T[]) {\n    if (!Array.isArray(conditions)) {\n      throw new Error(`\"${operator}\" operator expects to receive an array of conditions`);\n    }\n\n    super(operator, conditions);\n  }\n}\n\nexport const ITSELF = '__itself__';\nexport class FieldCondition<T = unknown> extends Condition<T> {\n  public readonly field!: string | typeof ITSELF;\n\n  constructor(operator: string, field: string | typeof ITSELF, value: T) {\n    super(operator, value);\n    this.field = field;\n  }\n}\n\nexport const NULL_CONDITION = new DocumentCondition('__null__', null);\nexport type ConditionValue<T> = T extends Condition<infer V> ? V : unknown;\n","import { Condition, CompoundCondition, NULL_CONDITION } from './Condition';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n\nexport function isCompound(operator: string, condition: Condition): condition is CompoundCondition {\n  return condition instanceof CompoundCondition && condition.operator === operator;\n}\n\nfunction flattenConditions<T extends Condition>(\n  operator: string,\n  conditions: T[],\n  aggregatedResult?: T[]\n) {\n  const flatConditions: T[] = aggregatedResult || [];\n\n  for (let i = 0, length = conditions.length; i < length; i++) {\n    const currentNode = conditions[i];\n\n    if (isCompound(operator, currentNode)) {\n      flattenConditions(operator, currentNode.value as T[], flatConditions);\n    } else {\n      flatConditions.push(currentNode);\n    }\n  }\n\n  return flatConditions;\n}\n\nexport function optimizedCompoundCondition<T extends Condition>(operator: string, conditions: T[]) {\n  if (conditions.length === 1) {\n    return conditions[0];\n  }\n\n  return new CompoundCondition(operator, flattenConditions(operator, conditions));\n}\n\nexport const identity = <T>(x: T) => x;\nexport const object = () => Object.create(null);\n\nexport const ignoreValue: IgnoreValue = Object.defineProperty(object(), '__@type@__', {\n  value: 'ignore value'\n});\nexport interface IgnoreValue {\n  readonly ['__@type@__']: 'ignore value'\n}\n\nexport function hasOperators<T>(\n  value: any,\n  instructions: Record<string, unknown>,\n  skipIgnore = false,\n): value is T {\n  if (!value || value && value.constructor !== Object) {\n    return false;\n  }\n\n  for (const prop in value) { // eslint-disable-line no-restricted-syntax, guard-for-in\n    const hasProp = hasOwnProperty(value, prop) && hasOwnProperty(instructions, prop);\n    if (hasProp && (!skipIgnore || value[prop] !== ignoreValue)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function objectKeysSkipIgnore(anyObject: Record<string, unknown>) {\n  const keys: string[] = [];\n  for (const key in anyObject) { // eslint-disable-line no-restricted-syntax\n    if (hasOwnProperty(anyObject, key) && anyObject[key] !== ignoreValue) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n}\n\nexport function pushIfNonNullCondition(conditions: Condition[], condition: Condition) {\n  if (condition !== NULL_CONDITION) {\n    conditions.push(condition);\n  }\n}\n","import { Condition } from './Condition';\nimport { optimizedCompoundCondition } from './utils';\n\nexport const buildAnd = (conditions: Condition[]) => optimizedCompoundCondition('and', conditions);\nexport const buildOr = (conditions: Condition[]) => optimizedCompoundCondition('or', conditions);\n","import {\n  FieldCondition,\n  CompoundCondition,\n  DocumentCondition,\n} from '../Condition';\nimport {\n  DocumentInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n} from '../types';\n\ninterface DefaultParsers {\n  compound: Exclude<CompoundInstruction['parse'], undefined>,\n  field: Exclude<FieldInstruction['parse'], undefined>,\n  document: Exclude<DocumentInstruction['parse'], undefined>\n}\n\nexport const defaultInstructionParsers: DefaultParsers = {\n  compound(instruction, value, context) {\n    const queries = Array.isArray(value) ? value : [value];\n    const conditions = queries.map(query => context.parse(query));\n    return new CompoundCondition(instruction.name, conditions);\n  },\n  field(instruction, value, context) {\n    return new FieldCondition(instruction.name, context.field, value);\n  },\n  document(instruction, value) {\n    return new DocumentCondition(instruction.name, value);\n  }\n};\n","import { Condition } from '../Condition';\nimport {\n  NamedInstruction,\n  ParsingInstruction,\n  FieldParsingContext,\n  ParsingContext,\n} from '../types';\nimport { buildAnd } from '../builder';\nimport { defaultInstructionParsers } from './defaultInstructionParsers';\nimport {\n  identity,\n  hasOperators,\n  object,\n  pushIfNonNullCondition,\n  objectKeysSkipIgnore,\n} from '../utils';\n\nexport type FieldQueryOperators<T extends {}> = {\n  [K in keyof T]: T[K] extends {} ? T[K] : never\n}[keyof T];\n\ntype ParsingInstructions = Record<string, NamedInstruction>;\n\nexport interface QueryOptions {\n  operatorToConditionName?(name: string): string\n  defaultOperatorName?: string\n  fieldContext?: Record<string, unknown>\n  documentContext?: Record<string, unknown>\n  useIgnoreValue?: boolean\n  mergeFinalConditions?(conditions: Condition[]): Condition\n}\n\nexport type ObjectQueryFieldParsingContext = ParsingContext<FieldParsingContext & {\n  query: {},\n  hasOperators<T>(value: unknown): value is T\n}>;\n\nexport class ObjectQueryParser<\n  T extends Record<any, any>,\n  U extends FieldQueryOperators<T> = FieldQueryOperators<T>\n> {\n  private readonly _instructions: ParsingInstructions;\n  private _fieldInstructionContext: ObjectQueryFieldParsingContext;\n  private _documentInstructionContext: ParsingContext<{ query: {} }>;\n  private readonly _options: Required<\n  Pick<QueryOptions, 'operatorToConditionName' | 'defaultOperatorName' | 'mergeFinalConditions'>\n  >;\n\n  private readonly _objectKeys: typeof Object.keys;\n\n  constructor(instructions: Record<string, ParsingInstruction>, options: QueryOptions = object()) {\n    this.parse = this.parse.bind(this);\n    this._options = {\n      operatorToConditionName: options.operatorToConditionName || identity,\n      defaultOperatorName: options.defaultOperatorName || 'eq',\n      mergeFinalConditions: options.mergeFinalConditions || buildAnd,\n    };\n    this._instructions = Object.keys(instructions).reduce((all, name) => {\n      all[name] = { name: this._options.operatorToConditionName(name), ...instructions[name] };\n      return all;\n    }, {} as ParsingInstructions);\n    this._fieldInstructionContext = {\n      ...options.fieldContext,\n      field: '',\n      query: {},\n      parse: this.parse,\n      hasOperators: <T>(value: unknown): value is T => hasOperators(\n        value,\n        this._instructions,\n        options.useIgnoreValue\n      ),\n    };\n    this._documentInstructionContext = {\n      ...options.documentContext,\n      parse: this.parse,\n      query: {}\n    };\n    this._objectKeys = options.useIgnoreValue ? objectKeysSkipIgnore : Object.keys;\n  }\n\n  setParse(parse: this['parse']) {\n    this.parse = parse;\n    this._fieldInstructionContext.parse = parse;\n    this._documentInstructionContext.parse = parse;\n  }\n\n  protected parseField(field: string, operator: string, value: unknown, parentQuery: {}) {\n    const instruction = this._instructions[operator];\n\n    if (!instruction) {\n      throw new Error(`Unsupported operator \"${operator}\"`);\n    }\n\n    if (instruction.type !== 'field') {\n      throw new Error(`Unexpected ${instruction.type} operator \"${operator}\" at field level`);\n    }\n\n    this._fieldInstructionContext.field = field;\n    this._fieldInstructionContext.query = parentQuery;\n\n    return this.parseInstruction(instruction, value, this._fieldInstructionContext);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  protected parseInstruction(\n    instruction: NamedInstruction,\n    value: unknown,\n    context: ParsingContext<{}>\n  ) {\n    if (typeof instruction.validate === 'function') {\n      instruction.validate(instruction, value);\n    }\n\n    const parse: typeof instruction.parse = instruction.parse\n      || defaultInstructionParsers[instruction.type as keyof typeof defaultInstructionParsers];\n    return parse(instruction, value, context);\n  }\n\n  protected parseFieldOperators(field: string, value: U) {\n    const conditions: Condition[] = [];\n    const keys = this._objectKeys(value);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const op = keys[i];\n      const instruction = this._instructions[op];\n\n      if (!instruction) {\n        throw new Error(`Field query for \"${field}\" may contain only operators or a plain object as a value`);\n      }\n\n      const condition = this.parseField(field, op, value[op as keyof U], value);\n      pushIfNonNullCondition(conditions, condition);\n    }\n\n    return conditions;\n  }\n\n  parse<Q extends T>(query: Q): Condition {\n    const conditions = [];\n    const keys = this._objectKeys(query);\n\n    this._documentInstructionContext.query = query;\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      const value = query[key];\n      const instruction = this._instructions[key];\n\n      if (instruction) {\n        if (instruction.type !== 'document' && instruction.type !== 'compound') {\n          throw new Error(`Cannot use parsing instruction for operator \"${key}\" in \"document\" context as it is supposed to be used in  \"${instruction.type}\" context`);\n        }\n\n        pushIfNonNullCondition(\n          conditions,\n          this.parseInstruction(instruction, value, this._documentInstructionContext)\n        );\n      } else if (this._fieldInstructionContext.hasOperators<U>(value)) {\n        conditions.push(...this.parseFieldOperators(key, value));\n      } else {\n        pushIfNonNullCondition(\n          conditions,\n          this.parseField(key, this._options.defaultOperatorName, value, query)\n        );\n      }\n    }\n\n    return this._options.mergeFinalConditions(conditions);\n  }\n}\n","import { Condition } from './Condition';\n\ntype ArgsExceptLast<F extends (...args: any[]) => any> =\n  F extends (a: any, c: any) => any\n    ? Parameters<(condition: Condition) => 0>\n    : F extends (a: any, b: any, c: any) => any\n      ? Parameters<(condition: Condition, value: Parameters<F>[1]) => 0>\n      : Parameters<(\n        condition: Condition,\n        value: Parameters<F>[1],\n        options: Parameters<F>[2],\n        ...args: unknown[]\n      ) => 0>;\n\nexport type Interpreter<T extends Condition, R> = (condition: T, ...args: any[]) => R;\nexport type AnyInterpreter = Interpreter<any, any>;\nexport interface InterpretationContext<T extends AnyInterpreter> {\n  interpret(...args: ArgsExceptLast<T>): ReturnType<T>;\n}\n\nfunction getInterpreter<T extends Record<string, AnyInterpreter>>(\n  interpreters: T,\n  operator: keyof T\n) {\n  const interpret = interpreters[operator];\n\n  if (typeof interpret !== 'function') {\n    throw new Error(`Unable to interpret \"${operator}\" condition. Did you forget to register interpreter for it?`);\n  }\n\n  return interpret;\n}\n\nexport interface InterpreterOptions {\n  numberOfArguments?: 1 | 2 | 3\n  getInterpreterName?(condition: Condition, context: this): string\n}\n\nfunction defaultInterpreterName(condition: Condition) {\n  return condition.operator;\n}\n\nexport function createInterpreter<T extends AnyInterpreter, U extends {} = {}>(\n  interpreters: Record<string, T>,\n  rawOptions?: U\n) {\n  const options = rawOptions as U & InterpreterOptions;\n  const getInterpreterName = options && options.getInterpreterName || defaultInterpreterName;\n  let interpret;\n\n  switch (options ? options.numberOfArguments : 0) {\n    case 1:\n      interpret = ((condition) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    case 3:\n      interpret = ((condition, value, params) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, params, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    default:\n      interpret = ((condition, value) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n  }\n\n  const defaultContext = {\n    ...options,\n    interpret,\n  } as InterpretationContext<T> & U;\n\n  return defaultContext.interpret;\n}\n","import { Condition } from './Condition';\nimport { Parse } from './types';\nimport { AnyInterpreter } from './interpreter';\n\ntype Bound<T> = T extends (first: Condition, ...args: infer A) => any\n  ? { (...args: A): ReturnType<T>, ast: Condition }\n  : never;\n\nexport function createTranslatorFactory<Lang, Interpreter extends AnyInterpreter>(\n  parse: Parse<Lang>,\n  interpret: Interpreter\n) {\n  return (query: Lang, ...args: unknown[]): Bound<Interpreter> => {\n    const ast = parse(query, ...args);\n    const translate = (interpret as any).bind(null, ast);\n    translate.ast = ast;\n    return translate;\n  };\n}\n","import { ObjectQueryParser } from './parsers/ObjectQueryParser';\n\nexport * from './Condition';\nexport * from './types';\nexport * from './interpreter';\nexport * from './translator';\nexport * from './builder';\nexport {\n  isCompound,\n  hasOperators,\n  identity,\n  object,\n  optimizedCompoundCondition,\n  ignoreValue,\n} from './utils';\nexport type {\n  IgnoreValue\n} from './utils';\nexport * from './parsers/ObjectQueryParser';\nexport * from './parsers/defaultInstructionParsers';\n/**\n * @deprecated use `ObjectQueryParser#parseInstruction` instead\n * TODO(major): remove\n */\nexport const parseInstruction = (ObjectQueryParser.prototype as any).parseInstruction;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}